{"About.html":{"url":"About.html","title":"目录","keywords":"","body":" 目录目录 Git 1 Git Practice Gitbook Plugins 1 Plugin Emoji 1 Gitbook Start 2 Gitbook Plugin Summary 3 Github Pages Gitbook Github 2 Github Local Pull Github 3 Github Action 4 Github Page Gitlab 1 Gitlab Start 2 Gitlab Deploy 3 Gitlab Config 4 Gitlab Runner Deploy 5 Gitlab Runner Management 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/About.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/About.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/About.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-05 10:55:17 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"./":{"url":"./","title":"序言","keywords":"","body":" 序言联系公众号序言 这是一本关于集合 Git、Github、Gitlab、Gitbook、gitOps 的书。 联系 Email: 1zoxun1@gmail.com WeChat: weke59 公众号 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/ 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Git/":{"url":"Git/","title":"Git","keywords":"","body":" Git1. 简史2. 简介3. 原理4. 功能5. git 与 SVN 区别6. Git特点6.1 优点6.2 缺点Git @[toc] 1. 简史 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。 Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统（参见 Git 分支）。 2. 简介 Git 是一个免费和开源的 分布式版本控制系统，旨在以速度和效率处理从小型到大型项目的所有内容。 Git易于学习， 占用空间小，性能快如闪电。它优于 SCM 工具，如 Subversion、CVS、Perforce 和 ClearCase，具有廉价的本地分支、方 便的暂存区域和 多个工作流等功能。 3. 原理 那么，简单地说，Git 究竟是怎样的一个系统呢？ 请注意接下来的内容非常重要，若你理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。 在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS、Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。 直接记录快照，而非差异比较 Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 基于差异（delta-based） 的版本控制）。 Figure 4. 存储每个文件与初始版本的差异. Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。 igure 5. 存储项目随时间改变的快照. 这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 稍后我们在Git 分支讨论 Git 分支管理时，将探究这种方式对待数据所能获得的益处。 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让你感到速度之神赐给了 Git 超凡的能量。 因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。 举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。 这也意味着你在离线或者没有 VPN 时，几乎可以进行任何操作。 如你在飞机或火车上想做些工作，就能愉快地提交（到你的 本地 副本，还记得吗？）， 直到有网络连接时再上传。如你回家后 VPN 客户端不正常，那么也仍能工作。 使用其它系统的话，做到这些是不可能或很费力的。 比如，用 Perforce 的话，没有连接服务器时几乎不能做什么事；而用 Subversion 和 CVS 的话， 你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。 这样似乎问题不大，但是你可能会惊喜地发现它带来的巨大的不同。 Git 保证完整性 Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。 Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据 你执行的 Git 操作，几乎只往 Git 数据库中 添加 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。但是一旦你提交快照到 Git 中， 就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 更深度探讨 Git 如何保存数据及恢复丢失数据的话题，请参考撤消操作。 三种状态 现在请注意，如果你希望后面的学习更顺利，请记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。 这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。 Figure 6. 工作目录、暂存区域以及 Git 仓库. 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。 基本的 Git 工作流程如下： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 如果 Git 目录中保存着特定版本的文件，就属于 已提交 状态。 如果文件已修改并放入暂存区，就属于 已暂存 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 已修改 状态。 在 Git 基础 一章，你会进一步了解这些状态的细节， 并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。 4. 功能 一般开发者的角度来看，git有以下功能： 从服务器上克隆数据库（包括代码和版本信息）到单机上。 在自己的机器上创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 新建一个分支，把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。 生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲 突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者 没有冲突，就通过。 一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再 向主开发者提交补丁。 从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能： 查看邮件或者通过其它方式查看一般开发者的提交状态。 打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源 项目，还要决定哪些补丁有用，哪些不用）。 向公共服务器提交结果，然后通知所有开发人员。 5. git 与 SVN 区别 Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。　　　　 　 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 6. Git特点 6.1 优点 适合分布式开发，强调个体； 公共服务器压力和数据量都不会太大； 速度快、灵活； 任意两个开发者之间可以很容易的解决冲突； 离线工作。 6.2 缺点 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息； 权限控制不友好；如果需要对开发者限制各种权限的建议使用SVN。 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Git/ 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Git/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Git/README.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Git/1_git_practice.html":{"url":"Git/1_git_practice.html","title":"git 实践","keywords":"","body":" git 实践1. 提交文件1.1 Git 初始化1.2 Git 状态1.3 Git 添加1.4 Git 提交1.5 Git 忽略2. 提交更改2.1 git status2.2 git diff2.3 git add2.4 git diff --staged2.5 git log2.6 git show3. 远程工作3.1 git remote3.2 git push3.3 git pull3.4 git log3.5 git pull4. 撤消更改4.1 git Checkout4.2 git reset4.3 git reset hard4.5 git revert5. 修复合并冲突5.1 git merge（合并）5.2 Viewing Conflict （查看冲突）5.3 resolving conflict（解决冲突）5.4 非快进5.5 git rebase5.6 Rebasing Pull Requests使用分支6.1 git branch6.2 List Branches6.3 Merge To Master（合并到master）6.4 Push Branches（推送分支）6.5 Clean Up Branches7. 查找bug7.1 git diff two Commits7.2 git log7.3 git bisect7.4 git blame7.5 部分提交合并master7.6 Cherry Picking7.7 解决 Cherry-pick冲突7.8 冲突后继续cherry-pick8. Re-writing History(重写历史)8.1 修改提交消息8.2 Squash Commits（组合提交）8.3 Re-order Commits（重新排序提交）8.4 拆分提交git 实践 1. 提交文件 1.1 Git 初始化 $ git init Initialized empty Git repository in /home/scrapbook/tutorial/.git/ $ pwd /home/scrapbook/tutorial 初始化存储库后，会创建一个名为.git的新隐藏子目录。该子目录包含 Git 用于存储其信息的元数据。 1.2 Git 状态 当目录是存储库的一部分时，它被称为工作目录。工作目录包含从存储库下载的最新版本以及尚未提交的任何更改。在您处理项目时，所有更改都在此工作目录中进行。 您可以使用命令查看哪些文件在您的工作目录和之前提交到存储库的文件之间发生了变化 $ git status On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) hello-world.js nothing added to commit but untracked files present (use \"git add\" to track) 1.3 Git 添加 要将文件保存或提交到 Git 存储库中，您首先需要将它们添加到暂存区。Git 有三个区域，一个工作目录，一个暂存区和存储库本身。在将更改提交到存储库之前，用户将更改从工作目录移动到暂存区，也称为提升。 Git 的关键方法之一是提交集中、小而频繁。暂存区允许您一次仅提升某些文件而不是工作目录中的所有更改，从而有助于维护此工作流程。 使用该命令git add 将hello-world.js添加到暂存区。 如果您在将文件添加到暂存区后进行其他更改，则在您再次添加文件之前不会反映更改。 1.4 Git 提交 将文件添加到暂存区后，需要将其提交到存储库。该命令git commit -m \"commit message\"将文件从暂存区移动到存储库并记录时间/日期、作者和提交消息，这些消息可用于为更改添加额外的上下文和推理，例如错误报告编号。 只会提交添加到暂存区的更改，不会包含工作目录中尚未暂存的任何文件。 每个提交都分配了一个 SHA-1 哈希值，它使您能够在其他命令中引用回提交。 1.5 Git 忽略 有时，您永远不想提交特定的文件或目录，例如本地开发配置。要忽略这些文件，请在存储库的根目录中创建一个.gitignore文件。 该的.gitignore文件允许你定义通配符您希望忽略，例如*的.tmp将忽略与扩展名为.tmp的所有文件的文件。 任何与定义的通配符匹配的文件都不会显示在git status输出中，并在尝试git add命令时被忽略。 $ echo '*.tmp' > .gitignore $ git add .gitignore $ git commit -m \"gitignore file\" [master (root-commit) 69e1e5a] gitignore file 1 file changed, 1 insertion(+) create mode 100644 .gitignore 2. 提交更改 2.1 git status 当前状态，我们的工作目录中已对先前提交的文件 commit.js 进行了更改，但尚未移动到暂存区。 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: committed.js Untracked files: (use \"git add ...\" to include in what will be committed) untracked.js no changes added to commit (use \"git add\" and/or \"git commit -a\") 2.2 git diff 该命令git diff使您能够将工作目录中的更改与先前提交的版本进行比较。默认情况下，该命令会比较工作目录和HEAD提交。 如果您希望与旧版本进行比较，请提供提交哈希作为参数，例如git diff . 与提交进行比较将输出所有已修改文件的更改。如果要将更改与单个文件进行比较，请提供名称作为参数，例如git diff committed.js. $ git diff committed.js . ESC[1mdiff --git a/committed.js b/committed.jsESC[m ESC[1mindex 12e7e7c..fc77969 100644ESC[m ESC[1m--- a/committed.jsESC[m ESC[1m+++ b/committed.jsESC[m ESC[36m@@ -1 +1 @@ESC[m ESC[31m-console.log(\"Committed File\")ESC[m ESC[32m+ESC[mESC[32mconsole.log(\"Demostrating changing a committed file\") 默认情况下，输出采用组合差异格式。该命令git difftool将加载您选择的外部工具以查看差异 2.3 git add 与之前的场景一样，为了提交更改，必须首先使用git add命令进行暂存。 $ git add committed.js 如果您重命名或删除文件，则需要在添加命令中指定这些文件以进行跟踪。替代品可以使用git mv，并git rm为混帐要执行的操作，包括更新的临时区域。 2.4 git diff --staged 一旦更改进入暂存区，它们将不会显示在git diff. 默认情况下，git diff将只比较工作目录而不是暂存区。 要将暂存区中的更改与之前的提交进行比较，请提供 staged 参数git diff --staged。这使您能够确保正确地暂存所有更改。 $ git diff --staged ESC[1mdiff --git a/committed.js b/committed.jsESC[m ESC[1mindex 12e7e7c..fc77969 100644ESC[m ESC[1m--- a/committed.jsESC[m ESC[1m+++ b/committed.jsESC[m ESC[36m@@ -1 +1 @@ESC[m ESC[31m-console.log(\"Committed File\")ESC[m ESC[32m+ESC[mESC[32mconsole.log(\"Demostrating changing a committed file\") 2.5 git log $ git log ESC[33mcommit ddc05ab990a12a81b59a1ca11d68dda2835707e8ESC[mESC[33m (ESC[m Author: Katacoda Scenario Date: Thu Nov 4 09:14:41 2021 +0000 Changed the output message in committed.js ESC[33mcommit cfb187d6ebaa88ea358df23c00ff49f6ac8ca7d2ESC[m Author: Katacoda Scenario Date: Thu Nov 4 08:57:27 2021 +0000 Initial Commit 日志输出的格式非常灵活。例如，要在一行上输出每个提交，命令是 $ git log --pretty=format:\"%h %an %ar - %s\" ddc05ab Katacoda Scenario 3 minutes ago - Changed the output message in com cfb187d Katacoda Scenario 20 minutes ago - Initial Commit 可以在使用访问的 git log 手册页中找到更多详细信息git log --help 2.6 git show 虽然 git log 会告诉您提交作者和消息，但要查看提交中所做的更改，您需要使用该命令 $ git show ESC[33mcommit ddc05ab990a12a81b59a1ca11d68dda2835707e8ESC[mESC[33m (ESC[m Author: Katacoda Scenario Date: Thu Nov 4 09:14:41 2021 +0000 Changed the output message in committed.js ESC[1mdiff --git a/committed.js b/committed.jsESC[m ESC[1mindex 12e7e7c..fc77969 100644ESC[m ESC[1m--- a/committed.jsESC[m ESC[1m+++ b/committed.jsESC[m ESC[36m@@ -1 +1 @@ESC[m ESC[31m-console.log(\"Committed File\")ESC[m ESC[32m+ESC[mESC[32mconsole.log(\"Demostrating changing a committed file\") (END) 与其他命令一样，默认情况下它将显示 HEAD 提交中的更改。使用git show 查看旧的改变。 3. 远程工作 3.1 git remote 远程存储库允许您共享来自或到您的存储库的更改。远程位置通常是构建服务器、团队成员机器或集中存储，例如 Github.com。使用git remote带有友好名称和远程位置的命令添加远程，通常是 HTTPS URL 或 SSH 连接，例如https://github.com/OcelotUproar/ocelite.git或git@github.com :/OcelotUproar/ocelite。吉特。 友好名称允许您引用其他命令中的位置。您的本地存储库可以根据您的场景引用多个不同的远程存储库。 此环境具有/s/remote-project/1的远程存储库位置。使用git remote，添加这个名为origin 的远程位置。 $ git remote add origin /s/remote-project/1 3.2 git push 当你准备好分享你提交你需要推动他们通过远程仓库git push。典型的 Git 工作流程是在您完成任务并在相关点（例如任务完成时）推送到远程时执行多个小提交，以确保团队内的代码同步。 该git push命令后跟两个参数。第一个参数是我们在第一步中定义的远程存储库的友好名称。第二个参数是分支的名称。默认情况下，所有 git 存储库都有一个主分支，用于处理代码。 $ git push origin master Counting objects: 3, done. Writing objects: 100% (3/3), 228 bytes | 228.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To /s/remote-project/1 * [new branch] master -> master 将 master 分支中的提交推送到 origin 远程。 3.3 git pull git push允许您将更改推送到远程存储库，git pull以相反的方式工作。git pull允许您将远程存储库中的更改同步到本地版本。 $ git pull origin master remote: Counting objects: 4, done. remote: Compressing objects: 100% (2/2), done. remote: Total 4 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (4/4), done. From /s/remote-project/1 * branch master -> FETCH_HEAD 6292b4d..5bd531a master -> origin/master Updating 6292b4d..5bd531a Fast-forward new-file.txt | 1 + staging.txt | 1 + 2 files changed, 2 insertions(+) create mode 100644 new-file.txt 3.4 git log 如前一场景所述，您可以使用该git log命令查看存储库的历史记录。该git show命令将允许您查看在每次提交中所做的更改。 $ git log ESC[33mcommit 5bd531a9ec87f1fb7b209548f520259c9ab3f93aESC[mESC[33m (ESC[m Author: Different User Date: Thu Nov 4 09:36:48 2021 +0000 Fix for Bug #1234 ESC[33mcommit 6292b4dc07b6f83180b671d867938288e11a23c5ESC[m Author: Katacoda Scenario Date: Thu Nov 4 09:21:22 2021 +0000 Message $ git show ESC[33mcommit 5bd531a9ec87f1fb7b209548f520259c9ab3f93aESC[mESC[33m (ESC[m Author: Different User Date: Thu Nov 4 09:36:48 2021 +0000 Fix for Bug #1234 ESC[1mdiff --git a/new-file.txt b/new-file.txtESC[m ESC[1mnew file mode 100644ESC[m ESC[1mindex 0000000..96716fbESC[m ESC[1m--- /dev/nullESC[m ESC[1m+++ b/new-file.txtESC[m ESC[36m@@ -0,0 +1 @@ESC[m ESC[32m+ESC[mESC[32mNewESC[m ESC[1mdiff --git a/staging.txt b/staging.txtESC[m ESC[1mindex c4eb839..b0f03f3 100644ESC[m ESC[1m--- a/staging.txtESC[m ESC[1m+++ b/staging.txtESC[m ESC[36m@@ -1 +1,2 @@ESC[m Staging AreaESC[m ESC[32m+ESC[mESC[32mSomething ChangedESC[m 在此示例中，输出git log显示了“ DifferentUser@JoinScrapbook.com ”的新提交，并带有消息“修复错误 #1234”。的输出git show以绿色突出显示添加到文件中的新行。 $ git log --grep=\"#1234\" ESC[33mcommit 5bd531a9ec87f1fb7b209548f520259c9ab3f93aESC[mESC[33m (ESC[m Author: Different User Date: Thu Nov 4 09:36:48 2021 +0000 Fix for Bug #1234 3.5 git pull 该命令git pull是两个不同命令的组合，git fetch并且git merge. Fetch 将更改从远程存储库下载到名为remotes//的单独分支中。可以使用 访问该分支git checkout。 使用git fetch是一种在不影响当前分支的情况下查看更改的好方法。分支的命名格式足够灵活，您可以拥有多个同名的远程和分支，并在它们之间轻松切换。 以下命令会将获取的更改合并到 master 中。 git merge remotes// master 在原始存储库中进行了其他更改。使用git fetch下载的更改，然后签出的分支进行查看。您可以使用命令查看所有远程分支的列表 git branch -r $ git fetch remote: Counting objects: 2, done. remote: Compressing objects: 100% (2/2), done. remote: Total 2 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (2/2), done. From /s/remote-project/1 5bd531a..7697d4c master -> origin/master $ git checkout remotes/origin/master Note: checking out 'remotes/origin/master'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b HEAD is now at 7697d4c Fix for Bug #42 4. 撤消更改 4.1 git Checkout 使用 Git 时，一个常见的场景是撤消工作目录中的更改。该命令git checkout会将工作目录中的所有内容替换为上次提交的版本。 如果要替换所有文件，请使用点 ( . ) 表示当前目录，否则使用空格分隔的目录/文件列表。 使用git checkout清除工作目录中的任何改变 $ git checkout . 4.2 git reset 如果您正在提交并已将文件添加到暂存区，但后来改变了主意，那么您将需要使用该git reset命令。git reset将文件从暂存区移回工作目录。如果要重置所有文件，请使用. 表示当前目录，否则列出以空格分隔的文件。这在尝试保持提交小而集中时非常有用，因为如果您添加了太多文件，您可以将文件移回暂存区。 使用以下命令将更改从暂存移回工作目录 git reset $ git reset HEAD . Unstaged changes after reset: M staging.txt 4.3 git reset hard git reset --hard将在一个命令中结合 git reset 和 git checkout 。结果将从暂存区中删除文件，并将工作目录恢复到上次提交的状态。 使用以下命令从暂存区和工作目录中删除更改 git reset git reset --hard HEAD 使用HEAD将清除状态回到上次提交，使用git reset --hard 允许您返回到任何提交状态。请记住， HEAD 是分支的最后一个提交哈希的别名。 4.5 git revert 如果您已经提交了文件但意识到自己犯了一个错误，那么该命令 git revert允许您撤消提交。该命令将创建一个新的提交，该提交与被还原的提交具有相反的影响。 如果您尚未推送更改，则git reset HEAD~1具有相同的影响，并将删除最后一次提交。 使用git revert恢复在最后的更改提交。 注意，这将打开一个 Vim 编辑器会话，为每个提交创建一个提交消息。要保存提交消息并退出 vim，请为每个 Vim 会话键入命令:wq。 $ git revert HEAD --no-edit [master 18d0da7] Revert \"Commit To Revert\" Date: Thu Nov 4 11:17:26 2021 +0000 1 file changed, 1 insertion(+), 1 deletion(-) 创建新提交背后的动机是在 Git 中重写历史是一种反模式。如果你已经推送了你的提交，那么你应该创建新的提交来撤消更改，因为在此期间其他人可能已经提交了。 要一次还原多个提交，我们使用字符~表示减号。例如， HEAD~2 是来自头部的两次提交。这可以与字符组合在一起......在两次提交之间说。 使用该命令git revert HEAD...HEAD~2恢复 HEAD 和 HEAD~2 之间的提交。 $ git revert HEAD...HEAD~2 --no-edit [master 7b75286] Revert \"Revert \"Commit To Revert\"\" Date: Thu Nov 4 11:21:30 2021 +0000 1 file changed, 1 insertion(+), 1 deletion(-) [master 0aea2ad] Revert \"Commit To Revert\" Date: Thu Nov 4 11:21:30 2021 +0000 1 file changed, 1 insertion(+), 1 deletion(-) 您可以使用该命令git log --oneline快速概览提交历史。 $ git log --oneline ESC[33m0aea2adESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[m Revert \"Commit To Revert\" ESC[33m7b75286ESC[m Revert \"Revert \"Commit To Revert\"\" ESC[33m18d0da7ESC[m Revert \"Commit To Revert\" ESC[33m9a606a6ESC[m Commit To Revert ESC[33m37ac4b8ESC[m New File ESC[33me263619ESC[m Fixing Error ESC[33md64dc98ESC[m First Commit 5. 修复合并冲突 5.1 git merge（合并） 该git fetch命令将更改下载到可以检出和合并的单独分支中。在合并期间，Git 将尝试自动合并提交。 当不存在冲突时，合并将“快进”，您无需执行任何操作。如果确实存在冲突，那么您将检索错误并且存储库将处于合并状态。 在您的环境中，已从远程存储库获取更改。 您现在需要合并来自 origin/master 的更改。 $ git merge remotes/origin/master fatal: refusing to merge unrelated histories 这将导致合并冲突。冲突表明合并失败，因为两个存储库都添加了该文件。我们将在接下来的步骤中解决此问题。 通过保持提交小而集中，您可以减少合并冲突的可能性。 该命令git pull是一个组合fetch和merge。 5.2 Viewing Conflict （查看冲突） 当发生冲突时，来自本地和远程的更改将以 unix diff 格式出现在同一个文件中。这与git diff使用的格式相同。 要读取格式，本地更改将出现在>>>>之间>> 遥控器/原点/主。 为了解决冲突，需要编辑文件以匹配我们想要的最终状态。我们将在下一步中演示这一点。 Git 支持不同的命令行和可视化合并工具，可以更轻松地解决冲突。该命令git mergetool将启动一个外部工具 5.3 resolving conflict（解决冲突） 解决冲突的最简单方法是使用git checkout --ours staging.txt或选择本地或远程版本git checkout --theirs staging.txt。如果您需要更多控制，那么您可以像平常一样手动编辑文件。 一旦文件处于所需状态，无论是手动还是使用 git checkout，您都需要暂存并提交更改。提交时，将创建默认提交消息，其中包含合并的详细信息和冲突的文件。 通过选择远程更改并使用git add后跟完成合并来解决冲突git commit。 如果您想在合并过程中恢复并重试，请使用该命令git reset --hard HEAD;返回到之前的状态。 使用git commit --no-edit时要使用的默认提交信息。 $ git checkout --theirs staging.txt $ git add staging.txt $ git commit --no-edit On branch master nothing to commit, working tree clean 5.4 非快进 为了模拟非快进合并，发生了以下情况。 1) 开发人员 A 从开发人员 B 拉取最新更改。 2) 开发人员 B 将更改提交到其本地存储库。 3) 开发人员 A 向其本地存储库提交无冲突的更改。 4) 开发人员 A 从开发人员 B 那里提取最新的更改。 在这种情况下，Git 无法快进来自开发人员 B 的更改，因为开发人员 A 进行了许多更改。 发生这种情况时，Git 将尝试自动合并更改。如果不存在冲突，则合并将完成，并且将创建一个新的提交以指示在该时间点发生的合并。 合并的默认提交消息是“合并分支”' 的 \"。这些提交可用于指示存储库之间的同步点，但也会产生嘈杂的提交日志。在下一步中，我们将研究替代方法。 从远程存储库中提取更改并使用以下命令使用默认提交消息。 $ git pull --no-edit origin master remote: Counting objects: 4, done. remote: Compressing objects: 100% (4/4), done. remote: Total 4 (delta 1), reused 0 (delta 0) Unpacking objects: 100% (4/4), done. From /s/remote-project/1 * branch master -> FETCH_HEAD d0ab773..654bdfd master -> origin/master fatal: refusing to merge unrelated histories $ git log --all --decorate --oneline ESC[33ma7312c0ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[m Fix for Bug #55 ESC[33m654bdfdESC[mESC[33m (ESC[mESC[1;31morigin/masterESC[mESC[33m)ESC[m Fix for Bug #58a ESC[33m3074197ESC[m Fix for Bug #58 ESC[33mdce3e2aESC[m Fixing Error ESC[33md0ab773ESC[m Fix for Bug #1234 ESC[33mf7126daESC[m First Commit 5.5 git rebase 合并提交消息可用于指示同步点，但它们也会产生大量垃圾信息。例如，如果您正在针对本地分支工作并且尚未推送，那么对于查看存储库的其他开发人员而言，这些附加信息毫无意义且令人困惑。 要解决此问题，您可以使用git rebase代替git merge. 变基将取消您所做的更改并重播分支中的更改，应用您的更改，就好像它们都发生在同一个分支上一样。结果是合并的干净历史记录和图表。 重要由于rebase将重播更改而不是合并，每个提交将有一个新的哈希 id。如果您或其他开发人员推/拉了存储库，则更改历史记录可能会导致 git 丢失提交。因此，您不应该对已公开的提交进行 rebase，例如推送提交，然后 rebase 来自不同分支的旧提交。结果将是具有不同哈希 ID 的先前公开提交 5.6 Rebasing Pull Requests 这种方法在使用远程分支时也适用，并且可以在使用以下方式发出拉取请求时应用： git pull --rebase 这就像您在每次提交之前完成了拉取请求一样。 使用分支 6.1 git branch branch分支是基于另一个分支创建的，通常是 master。该命令git branch 采用现有分支并创建一个单独的分支来工作。此时两个分支是相同的。 要切换到分支，请使用该git checkout 命令。 $ git branch new_branch master $ git checkout new_branch Switched to branch 'new_branch' 6.2 List Branches $ git branch masterESC[m * ESC[32mnew_branchESC[m 附加参数-a将包括远程分支，而包括-v将包括分支的 HEAD 提交消息 $ git branch -va master ESC[m b54bcf8 First Commit on master * ESC[32mnew_branchESC[m a6eb09c Commit on branch 6.3 Merge To Master（合并到master） 已提交到新分支。要将其合并到master 中，您首先需要检出目标分支，在本例中为 master，然后使用 'git merge' 命令合并来自分支的提交。 $ git checkout master Switched to branch 'master' $ git merge new_branch Updating b54bcf8..8eb1a99 Fast-forward new-file-6.txt | 1 + staging.txt | 2 +- 2 files changed, 2 insertions(+), 1 deletion(-) create mode 100644 new-file-6.txt 6.4 Push Branches（推送分支） 如果你想将一个分支推送到远程，那么使用命令 git push 6.5 Clean Up Branches 清理分支对于消除噪音和混乱很重要。要删除您需要提供参数的一个分支-d，例如git branch -d 7. 查找bug 7.1 git diff two Commits 该git diff命令是比较提交之间更改的最简单的命令。它将输出两次提交之间的差异。 您可以通过提供两次提交的哈希 ID 或指针（blob）来直观地进行任何两次提交 $ git diff HEAD~2 HEAD ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex 96e99d0..9f53aec 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -2,4 +2,6 @@ESC[m Lorem ipsum dolor sit amet, consectetuer adipiscing elit.ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m ESC[32m+ESC[mESC[32mMorbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[32m+ESC[mESC[32mPraesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat ESC[m 7.2 git log 虽然git log可以帮助您查看提交消息，但默认情况下它不会输出实际更改的内容。值得庆幸的是，该命令非常灵活，附加选项提供了对存储库历史的有用见解。 要在简短的视图中查看提交的概述，请使用命令 $ git log --oneline ESC[33mbb37e28ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[m Final Item ESC[33md029598ESC[m New Item ESC[33ma097903ESC[m Initial commit of the list 要输出具有更改内容差异的提交信息，您需要包含-p提示，例如 $ git log -p ESC[33mcommit bb37e28391de9e741c2852396c5e16ea38bc0d06ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[ Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 Final Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex def310d..9f53aec 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -3,4 +3,5 @@ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m Morbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[32m+ESC[mESC[32mPraesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat ESC[m ESC[33mcommit d029598d9d0fbd6fcf73133eeee75217d0ecfeebESC[m Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 New Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex 96e99d0..def310d 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -2,4 +2,5 @@ESC[m Lorem ipsum dolor sit amet, consectetuer adipiscing elit.ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m ESC[32m+ESC[mESC[32mMorbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[m ESC[33mcommit a097903bb0c59689c6cd853943e073e92e18f1d6ESC[m Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 这将输出整个历史。您可以使用许多不同的选项对其进行过滤。所述-n 指定从HEAD提交至显示器的限制。例如 git log -p -n 2显示 HEAD 和 HEAD~1。 $ git log -p -n 2 ESC[33mcommit bb37e28391de9e741c2852396c5e16ea38bc0d06ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[ Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 Final Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex def310d..9f53aec 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -3,4 +3,5 @@ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m Morbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[32m+ESC[mESC[32mPraesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat ESC[m ESC[33mcommit d029598d9d0fbd6fcf73133eeee75217d0ecfeebESC[m Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 New Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex 96e99d0..def310d 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -2,4 +2,5 @@ESC[m Lorem ipsum dolor sit amet, consectetuer adipiscing elit.ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m ESC[32m+ESC[mESC[32mMorbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[m 如果您知道时间段，那么您可以使用--since=\"2 weeks ago\"和 __--until=\"1 day ago\"在特定日期之前的提交之间使用时间段。 使用该命令git log --grep=\"Initial\"将输出在其提交消息中包含“Initial”一词的所有提交。如果您使用错误跟踪编号标记提交，这将非常有用。 正如我们在合并场景中所讨论的，由于使用合并通知提交，您的提交历史可能会变得嘈杂。要删除它们，请使用 git log提供参数-m。 7.3 git bisect 这些git bisect命令允许您对存储库进行二进制搜索，以查找哪个提交引入了问题和回归。在这一步中，我们将在 list.html 中找到忘记 HTML 标签的提交。 Git bisect 需要很多步骤，执行这些步骤才能看到结果。 要进入二等分模式，请使用命令git bisect start。这表明它包含您在引入时要搜索的问题。 我们已经定义了错误提交发生的位置，现在需要定义上次已知的良好提交何时使用git bisect good HEAD~5.在这种情况下，它是五次提交前。 第 3 步将检出坏提交和好的提交之间的提交。然后，您可以检查提交、运行测试等以查看错误是否存在。在本例中您可以使用cat list.html 这个提交看起来不错，因为一切都有正确的 HTML 标签。我们告诉 Git 我们很高兴使用git bisect good.这将自动检查在最后一次已知的良好提交中间的提交，如步骤 5 和我们的错误提交中所定义。 正如我们之前所做的那样，我们需要检查提交是好是坏。 cat list.html 此提交缺少 HTML 标签。usinggit bisect bad将结束搜索并输出相关的提交 ID。 7.4 git blame 虽然“责备”文化是不可取的，但了解谁在文件的某些部分工作以帮助将来进行改进可能会很有用。这是git blame可以提供帮助的地方。 git blame 显示最后修改文件每一行的修订版和作者。 在文件上运行blame将输出谁最后接触每一行。 $ git blame list.html ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 1) ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 2) Lorem ipsum dolor sit amet, consectetuer adipiscing elit. ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 3) Aliquam tincidunt mauris eu risus. ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 4) Vestibulum auctor dapibus neque. d029598d (Katacoda Scenario 2021-11-04 11:55:52 +0000 5) Morbi in sem quis dui placerat ornare. Pellentesque odio nisi, eui bb37e283 (Katacoda Scenario 2021-11-04 11:55:52 +0000 6) Praesent dapibus, neque id cursus faucibus, tortor neque egestas a 1958fba4 (Katacoda Scenario 2021-11-04 12:14:30 +0000 7) Vestibulum auctor dapibus neque ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 8) 如果我们知道我们关心的行，那么我们可以使用-L参数来提供要输出的行范围。 $ git blame -L 6,8 list.html bb37e283 (Katacoda Scenario 2021-11-04 11:55:52 +0000 6) Praesent dapibus, neque id cursus faucibus, tortor neque egestas a 1958fba4 (Katacoda Scenario 2021-11-04 12:14:30 +0000 7) Vestibulum auctor dapibus neque ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 8) 7.5 部分提交合并master 小提交的优点之一是您可以挑剔要合并的内容。 这个问题特别涉及长期存在的分支，这些分支已经与主分支过时，导致太多冲突而无法简单地合并。这在非常活跃的开源项目中很常见。 发生这种情况时，您希望能够挑选出单独的提交并将它们合并到主分支中。 该环境已配置了一个存储库，其中包含在单独的分支中开发的 HTML 列表。在这种情况下，我们将从这个分支中选择某些我们想要在 master 中结束的提交。 7.6 Cherry Picking 在这种情况下，我们在 _new分支中有许多提交，它创建了两个 html 文件。在这种情况下，我们只关心对其中一个文件的更改，但是如果我们合并了分支，那么我们将合并所有五个提交和不需要的更改。 要合并单个提交，我们使用该git cherry-pick 命令。这与merge 的行为方式类似，如果不存在冲突，则提交将自动合并。 按照以下步骤合并我们感兴趣的三个提交。我们希望按照它们在原始存储库中发生的顺序重放提交。 选择带有消息“初始提交，无项目”的提交 用“初始列表”消息挑选提交 选择带有消息“将最终项目添加到列表中”的提交 我们之前使用过 HEAD 来指示当前分支的尖端。您可以使用语法 跨分支引用~#。例如，new_branch~3指的是分支中倒数第二个提交，在这种情况下，它具有提交消息“初始提交，没有项目” 7.7 解决 Cherry-pick冲突 以同样的方式，合并会导致冲突，Cherry Picking也会导致冲突。您解决以同样的方式冲突与手动或者合并一个分支固定的文件或选择他们或者我们通过git checkout。 如果你觉得你犯了一个错误，你可以停止并使用git cherry-pick --abort Cherry-pick第二个列表的创建使用 git cherry-pick new_branch~1 这将导致合并冲突。使用git checkout并选择选择的提交解决冲突。 准备好后继续，我们将完成cherry pick。 git cherry-pick new_branch~1 git status git diff git checkout --theirs list2.html 7.8 冲突后继续cherry-pick 解决冲突后，您可以使用命令继续进行cherry pick git cherry-pick --continue。 与使用merge类似，解决cherry-pick 将导致提交。 首先添加先前冲突的项目，然后使用--continue选项来完成樱桃选择。 $ git add list2.html $ git cherry-pick --continue [master d95af12] q :q! q q Date: Thu Nov 4 12:40:46 2021 +0000 1 file changed, 4 insertions(+), 1 deletion(-) 此时，默认编辑器（在本例中为 vim）将弹出，允许您编辑精心挑选的提交消息，以包含冲突的详细信息及其解决方式。要保存和退出 vim 类型：wq 8. Re-writing History(重写历史) Git 的一个重要方面是您保持存储库和历史记录的干净程度。一个干净的存储库更容易使用和理解发生了什么。 此场景将介绍如何使用 Rebase 重写 Git 历史记录以重构提交，以确保在推送更改之前它们是可理解的。您应该只重新设置未通过推送与其他人共享的提交。重新提交提交会导致他们的提交 ID 发生变化，这可能会导致丢失未来的提交。 8.1 修改提交消息 使用git rebase -interactive. 通过将 rebase 置于交互模式，您可以更好地控制要进行的更改。启动到交互模式后，您将获得六个命令来执行存储库中的每个提交。通过使用 Vim 默认打开的编辑器，您可以定义要在每次提交时执行的操作。 在这个例子中，我们想要改变提交。要将其置于此状态，我们需要更改提交旁边的单词“pick”以匹配基于 Vim 窗口中显示的列表要执行的操作，在本例中为“reword”。 在本例中，我们要更改提交消息。 首先，我们需要使用以下命令进入 Interactive Rebase 模式 git rebase --interactive --root 开始使用 Vim 可能有点令人困惑，要编辑文本，您首先需要输入i，这将使您进入“插入模式”。 我们想编辑第一条提交消息“列表的初始提交”中的“提交”错字。对于提交，更改单词“pick”以匹配我们要在提交时执行的命令，在本例中为“reword”。 要保存并退出，请按esc键然后:wq。这将打开另一个 Vim 编辑器窗口。 再次使用 Vim，编辑提交消息以将“comit”更改为“commit”。保存并退出 Vim 后，您将看到 Git 更改提交的输出。使用git log --oneline以查看更新的提交信息。 该--root参数可以让你变基在库中的所有提交，其中包括第一次提交。 更改上次提交消息的更快替代方法是git commit --amend使用 Vim 进行更改。 8.2 Squash Commits（组合提交） 在您的本地环境中进行了一系列 8 次不同的提交。当时这些提交是有意义的，但现在它们只需要一次提交。衍合使用，我们需要压扁的提交在一起。 使用git rebase --interactive HEAD~8，我们有从 HEAD 到最后 0 的提交范围。要压缩我们需要一个基本提交，所有内容都将被压缩到其中。因此，将第一个提交保留为“pick”，但将其余提交更改为“squash”。 保存后，您将有机会进行编辑。默认情况下，Git 提交消息将是先前压缩的提交消息的组合。 当我们进入 Interactive Rebase 时，我们可以指定我们要使用以下命令修改前 8 次提交 git rebase --interactive HEAD~8 在前一阶段，我们使用了reword。这里我们要使用壁球。我们想将 8 个提交压缩为一个，如果我们将所有提交标记为压缩，那么我们会收到错误“不能在没有先前提交的情况下‘压缩’”，因为没有一个基本提交来压缩所有内容。 为了压缩提交，我们需要将第一个提交作为我们的基础，并用squash标记以下 7 。 在保存和退出 Vim 时，我们会看到一个新的 Vim 窗口，其中列出了 rebase 中 8 条提交消息的组合。 保存提交消息后，历史将被修改。你可以看到这个使用git log --在这里插入代码片oneline 8.3 Re-order Commits（重新排序提交） 我们想重新排序我们的最后两个提交。使用HEAD~2允许我们修改它们。 git rebase --interactive HEAD~2 使用 Vim，只需重新排列行，保存并退出，提交将匹配顺序。 8.4 拆分提交 就像压缩提交一样，有时将更改从提交中分离出来是很有用的，以便让它们保持专注并使挑选或恢复更容易。 拆分提交是一个两个阶段的过程。首先，我们需要定义要拆分的提交，然后需要定义新提交的外观。 1.定义拆分提交 在这里，我们要拆分之前的提交。我们使用git rebase --interactive HEAD~1 与之前的变基一样，我们需要将任务更改为编辑 我们现在处于交互式编辑历史的状态。Git 将记录所有更改，最终结果将应用于存储库。 2.拆分提交 在定义我们要编辑提交后，我们现在处于允许我们更改历史记录的状态。 由于我们想要拆分现有提交，因此我们首先需要使用git reset HEAD^. 提交已被删除，但文件仍然存在。我们现在可以按照我们以前的意愿执行提交，作为两个单独的操作。 执行命令： git add file3.txt git commit -m \"File 3\" git add file4.txt git commit -m \"File 4\" 一旦对存储库的状态感到满意，我们就会告诉 Git 继续 rebase 并使用--continue更新存储库。 git rebase --continue 您可以使用以下命令查看输出和两个新提交 git log --oneline 官方文档 https://git-scm.com/book/en/v2/Getting-Started-Installing-Git 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Git/1_git_practice.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Git/1_git_practice.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Git/1_git_practice.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Github/":{"url":"Github/","title":"Github","keywords":"","body":" github 介绍github是什么GitHub与Git关系github创建项目如何用好 GitHub敏捷软件开发git提交规范工作写法常规写法开源应用、开源库写法github 介绍 github是什么 GitHub 是一个共享虚拟主机服务，用于存放使用Git版本控制的软件代码和内容项目。它由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。 它还是什么? 网站 免费博客 管理配置文件 收集资料 简历 管理代码片段 托管编程环境 写作 版本管理与软件部署 GitHub与Git关系 Git是一个分布式的版本控制系统，最初由Linus Torvalds编写，用作Linux内核代码的管理。在推出后，Git在其它项目中也取 得了很大成功，尤其是在Ruby社区中。目前，包括Rubinius、Merb和Bitcoin在内的很多知名项目都使用了Git。Git同样可以被 诸如Capistrano和Vlad the Deployer这样的部署工具所使用。 GitHub可以托管各种git库，并提供一个web界面，但与其它像 SourceForge或Google Code这样的服务不同，GitHub的独特卖 点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将 修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码 玩家的MySpace。 github创建项目 git本地项目上传github或gitlab详解 如何用好 GitHub 如何用好 GitHub，并实践一些敏捷软件开发是一个很有意思的事情.我们可以在上面做很多事情,从测试到CI,再到自动部署. 敏捷软件开发 瀑布流是怎样的？ 一个项目的组成： 代码 CI 测试 自动化测试 文档 版本管理 自动部署 代码模块化 自动化测试 代码质量与重构 git提交规范 工作写法 格式 [任务卡号] xx & xx: do something 比如： [PHODAL-0001] ladohp & phodal: update documents ，解释如下： PHODAL-0001 ，业务的任务卡号，它可以帮我们找到某个业务修改的原因，即点出相应 bug 的来源 ladohp & phodal ，结对编程的两个人的名字，后者（phodal）一般是写代码的人，出于礼貌就放在后面了。由于 Git的提交人只显示一个，所以写上两个的名字。当提交的人不在时，就可以问另外一个人修改的原因。 update documents ，我们做了什么事情 缺点：而对于采用看板的团队来说，并不存在任务卡号这种东西，因此就需要一种额外的作法。 常规写法 格式 [任务分类] 主要修改组件（可选）：修改内容 示例 1， [T] tabs: add icons 。其中的 T 表示这是一个技术卡， tabs 表示修改的是Tabs， add icons 则表示添加了图标。 示例 2， [SkillTree] detail: add link data 。其中的 SkillTree 表示修改的是技能树 Tab 下的内容， detail 则表示修改的是详情页， add link data 则表示是添加了技能的数据 这样做的主要原因是，它可以轻松也帮我 filter 出相应业务的内容。 缺点：要这样做需要团队达到一致，因此付出一些额外的成本。 开源应用、开源库写法 与我们日常工作稍有不同的是：工作中的 Release 计划一般都是事先安排好的，不需要一些CHANGELOG 什么的。而开源应用、开源库需要有对应的 CHANELOG，则添加了什么功能、修改了什么等等。毕竟有很多东西是由社区来维护的。 诸如： docs(changelog): update change log to beta.5 中： docs 则对应修改的类型 changelog 则是影响的范围 subject 则是对应做的事件 对应的类型有： build: 影响构建系统或外部依赖关系的更改（示例范围：gulp，broccoli，npm） ci: 更改我们的持续集成文件和脚本（示例范围：Travis，Circle，BrowserStack，SauceLabs） docs: 仅文档更改 feat: 一个新功能 fix: 修复错误 perf: 改进性能的代码更改 refactor: 代码更改，既不修复错误也不添加功能 style: 不影响代码含义的变化（空白，格式化，缺少分号等） test: 添加缺失测试或更正现有测试 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Github/ 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Github/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Github/README.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Github/2_github_local_pull_github.html":{"url":"Github/2_github_local_pull_github.html","title":"2_github_local_pull_github","keywords":"","body":" 本地同步github仓库1 安装与配置2. 界面创建github3 创建仓库上传github或gitlab4. 上传本地项目到github或gitlab5. 解决错误本地同步github仓库 1 安装与配置 1.win下载git工具：git bash 、git gui 、git cmd https://git-scm.com/downloads linux环境下如果yum源有git包， yum -y install git-all.noarch 若没有还是去官网下载。 2.打开git bash，执行以下命令，配置git的用户名与邮箱 $ git config --global user.name \"hanyuntao\" $ git config --global user.email \"hanyuntaocn@163.com\" $ git config --list 3。 设置SSH key（git中sshkey有何作用？） 首先检查是否已生成密钥cd ~/.ssh，如果返回的ls有3个文件,则密钥已经生成。 $ ssh-keygen -t rsa -C \"hanyuntaocn@163.com\" 生成密钥 把id_rsa.pub的公钥内容复制 ，然后找到github的用户设置的列表中SSH and GPG keys选项，添加 new SSH key，随便起个名字，粘贴复制公钥。 ssh -T git@github.com #远程登录git 2. 界面创建github 3 创建仓库上传github或gitlab 非常简单，起名字，描述库的作用功能，设置公有，私有。 是否设置创建README，如果之前没有设置它，上传文件就会报错。 否则执行以下命令： git init echo \"# github-roam\" >> README.md git add README.md git commit -m 'first_commit' git remote add origin https://github.com/findingsea/myRepoForBlog.git git push origin master 4. 上传本地项目到github或gitlab cd d:test #某一个文件目录 git init #初始化为库 git add . #添加上传内容 ,如果报错，尝试git add --all git commit -m \"test four\" #编写描述内容 git remote #查看远程主机名（一个远程库伪主机的主机名） git remote add origin https://github.com/Ghostwritten/tutorial.git 添加远程库名 git push origin master #推送到库 5. 解决错误 错误1 1.To https://github.com/Ghostwritten/test.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'https://github.com/Ghostwritten/test.git' git push origin master --force #强制推送到库名下 错误2 git remote add origin https://github.com/findingsea/myRepoForBlog.git，出现错误： 　　fatal: remote origin already exists 则执行以下语句： git remote rm origin git remote add origin https://github.com/findingsea/myRepoForBlog.git 错误3 在执行git push origin master时，报错： error:failed to push som refs to....... 则执行以下语句： git pull origin master 先把远程服务器github上面的文件拉先来，再push 上去。 可以看到我们的本地项目已经上传到了github上了。 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Github/2_github_local_pull_github.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Github/2_github_local_pull_github.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Github/2_github_local_pull_github.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitbook/":{"url":"Gitbook/","title":"Gitbook","keywords":"","body":" Gitbook1. 简介2. 官方 Gitbook3. 自定义 Gitbook4. 参考Gitbook 1. 简介 Gitbook 是一款优秀的开源文档管理工具, 具有丰富的开源插件，它的源码可以在 GitHub 上获取。 GitBook 是基于 Node.js 的开源命令行工具，用于输出漂亮的电子书。 GitBook 支持 Markdown 和 AsciiDoc 两种语法格式，能够输出 html，pdf，epub，mobi或者输出为静态网页多种格式。 GitBook 特性： Markdown 或 AsciiDoc 语法 多类型支持：网站(html)或电子书 (pdf, epub, mobi) 多语言 目录、大纲 封面 模板和变量 模板继承 插件 主题 2. 官方 Gitbook 在线编辑界面 预览效果 3. 自定义 Gitbook 预览效果 4. 参考 https://www.gitbook.com/ https://docs.gitbook.com/ http://www.zhaowenyu.com/gitbook-doc/ https://snowdreams1006.github.io/myGitbook/ 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitbook/ 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/README.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 16:03:11 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitbook/2_gitbook-plugin-summary.html":{"url":"Gitbook/2_gitbook-plugin-summary.html","title":"gitbook 插件 summary","keywords":"","body":" gitbook 插件 summarygitbook 插件 summary Gitbook 插件：自动生成 summary.md 文件内容，如果有很多md文件，这个插件可以帮助你生成初始版本。 $ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install ` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (git-in-action) version: (1.0.0) description: This is a book about git、github、gitlab and gitbook. entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to /root/github/git-in-action/package.json: { \"name\": \"git-in-action\", \"version\": \"1.0.0\", \"description\": \"This is a book about git、github、gitlab and gitbook.\", \"main\": \"index.js\", \"dependencies\": { \"gitbook-plugin-summary\": \"^1.1.0\", \"gitbook-plugin-theme-comscore\": \"^0.0.3\" }, \"devDependencies\": {}, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } Is this OK? (yes) yes 安装 gitbook-plugin-summary $ npm install gitbook-plugin-summary $ npm install -g gitbook-summary $ book sm $ cat SUMMARY.md # GitBook Handbook - Git * [1 Git Introduce](git/1_git_introduce.md) * [2 Git Command](git/2_git_command.md) * [3 Git Reset](git/3_git_reset.md) * [4 Git Ssh Login Without Secret](git/4_git_ssh_login_without_secret.md) - Github * [1 Github Introduce](github/1_github_introduce.md) * [2 Github Local Pull Github](github/2_github_local_pull_github.md) * [3 Github Action](github/3_github_action.md) * [4 Github Page](github/4_github_page.md) - Gitlab * [1 Gitlab Deploy](gitlab/1_gitlab_deploy.md) * [2 Gitlab Runner Deploy](gitlab/2_gitlab_runner_deploy.md) * [3 Gitlab Config](gitlab/3_gitlab_config.md) * [4 Gitlab Pipline](gitlab/4_gitlab_pipline.md) * [5 Gitlab Ci Config](gitlab/5_gitlab_ci_config.md) * [Information](information.md) [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 注意：如果没有命令book，执行: ln -s /usr/local/node-v10.24.0-linux-x64/bin/book /usr/local/bin/ 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitbook/2_gitbook-plugin-summary.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/2_gitbook-plugin-summary.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/2_gitbook-plugin-summary.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitbook/3_github_pages_gitbook.html":{"url":"Gitbook/3_github_pages_gitbook.html","title":"gitbook 发布 github pages","keywords":"","body":" gitbook 发布 github pages1. github 创建仓库2. 本地创建github仓库2.1 linux3. 配置 github pages3.1 新建分支3.2 删除不需要的文件3.3 添加忽略文件3.4 复制_book文件夹到分支根目录3.5 推送3.6 验证4. 推送至gitbook仓库gitbook 发布 github pages 1. github 创建仓库 例如：git-handbook 2. 本地创建github仓库 2.1 linux 仓库名：git-handbook 初始化配置操作，推送github pages $ mkdir git-handbook $ cd git-handbook $ gitbook init $ gitbook build $ ls _book/ gitbook index.html search_index.json $ ls _book README.md SUMMARY.md $ git init $ echo \"*~\" > .gitignore $ echo \"_book\" >> .gitignore $ cp -r _book/* . $ ls _book gitbook index.html README.md search_index.json SUMMARY.md $ git add --all $ git commit -m \"Publish book\" $ git remote add origin https://github.com/Ghostwritten/git-handbook.git $ git push -u origin master Username for 'https://github.com': ghostwritten Password for 'https://ghostwritten@github.com': 3. 配置 github pages 3.1 新建分支 git checkout --orphan gh-pages 3.2 删除不需要的文件 切换到pages分支后，我们需要将_books目录之外的文件都清理掉： git rm --cached -r . git clean -df rm -rf *~ 3.3 添加忽略文件 使用文本编辑器，创建名为.gitignore的文件，内容如下： *~ _book .DS_Store 通过.gitignore文件，本地仓库将忽略临时文件和_book文件夹。 3.4 复制_book文件夹到分支根目录 cp -r _book/* . 3.5 推送 git add . git commit -m '更新说明' git push -u origin gh-pages master与gh-pages的不同之处： 3.6 验证 如果没有自定义的域名，你访问的方式地址为：http://.github.io/git-handbook 这里我配置了自己的域名，ghostwritten*.github.io* 重定向到了个人站点 smoothies.com.cn 4. 推送至gitbook仓库 注册gitbook 与仓库同名 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitbook/3_github_pages_gitbook.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/3_github_pages_gitbook.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/3_github_pages_gitbook.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitbook/Plugins/":{"url":"Gitbook/Plugins/","title":"Plugins","keywords":"","body":" 插件1. 默认插件2. 添加和移除插件3. 插件配置pluginsConfig4. 插件安装4.1 方法一4.2 方法二4.3 方法三5. 插件预览插件 1. 默认插件 Gitbook默认带有7个插件（功能性5个，搜索有两个，主题一个）： livereload 热加载插件 highlight 语法高亮插件 search 搜索插件 lunr 搜索插件后台服务 sharing 分享插件 fontsettings 字体设置插件 theme-default 主题 2. 添加和移除插件 在 book.json 中的 plugins 模块能够配置，能够使 Gitbook 的功能更丰富。 在 plugins 中添加对应的插件名称 \"plugins\": [ \"highlight\", \"-search\", \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\" ] 其中\"-search\"中的 - 符号代表去除默认自带的插件 3. 插件配置pluginsConfig 部分插件在引入后需要进行详细的配置，可以在 pluginsConfig 中加配置说明。 \"pluginsConfig\": { \"insert-logo\": { \"url\": \"images/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } 4. 插件安装 4.1 方法一 插件无需单独下载安装，只有在 book.json 中配置好对应的插件，执行 gitbook install, 缺少的插件就会自动下载安装 gitbook install . 4.2 方法二 自定义的插件也可以通过 npm 或者将解压后的包复制到 node_modules 目录中进行安装。 npm install gitbook-plugin-xxx 4.3 方法三 也可以从源码GitHub地址中下载，放到 node_modules 文件夹里（GitHub地址在进入插件地址右侧的GitHub链接）. 5. 插件预览 模块名称 功能描述 accordion 手风琴折叠模块 ace 代码 ACE 显示 advanced-emoji 显示 emoji 表情 alerts 告警级别信息提示 anchor-navigation-ex 悬浮目录和回到顶部 ancre-navigation 悬浮目录和回到顶部 auto-scroll-table 表格滚动条 back-to-top-button 当页面超过一屏幕时，会显示一个 回到顶部按钮 change_girls 可自动切换的背景 click-reveal 默认隐藏，点击可显示 code 代码添加行号&复制按钮 copy-code-button 代码复制按钮 custom-favicon 修改网页标题图标 favicon chapter-fold 导航目录默认折叠 Chart 绘制图形 donate 贡献 disqus 评论系统 emphasize 为文字加上底色 expandable-chapters 导航目录折叠扩展 expandable-chapters-small expandable-chapters-small edit-link 添加编辑按钮 favicon 显示网站图标 flexible-alerts flexible-alerts github 在右上角添加 github 图标 hide-element 可以隐藏不想看到的元素，比如导航栏中 Published by GitBook insert-logo 插入logo include-codeblock 包含或显示文件 include-csv 显示 CSV 文件内容 KaTex 数学公式支持 klipse klipse 嵌入类似IDE的功能 lightbox 单击查看图片 点击图片可显示，大小不变 lunr lunr local-video 视频 mermaid 流程图 Mermaid-gb3 流程图 Musicxml 乐谱渲染 page-copyright 页面页脚版权 page-toc-button 悬浮目录 page-top page-top.md page-treeview 生成页内目录 page-treeview-simle 生成页内目录精简版本 pageview-count 阅读量计数 popup 单击图片，在新页面查看大图 prism 语法高亮 PlantUML UML reward 赞赏组件 rss RSS 订阅 search 搜索 search-pro 高级搜索 search-plus search-plus sectionx.md sectionx [simple-page-toc(cat-article-content.md) plugins/simple-page-toc sharing-plus 分享当前页面 sidebar-style 会替换掉 Published by GitBook splitter 侧边栏宽度可调节 sitemap-general 自动生成 sitemap 文件 summary 自动生成 SUMMARY.md tbfed-pagefooter 页面添加页脚 tags tags todo todo Terminal Terminal 终端 Version-select 文档多版本 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitbook/Plugins/ 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/Plugins/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/Plugins/README.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitbook/Plugins/1_plugin_Emoji.html":{"url":"Gitbook/Plugins/1_plugin_Emoji.html","title":"emoji 表情包","keywords":"","body":" Emoji 表情包1. advanced-emoji 插件1.1 安装1.2 配置1.3 效果Emoji 表情包 1. advanced-emoji 插件 advanced-emoji 插件：支持显示 emoji 表情。 1.1 安装 npm i gitbook-plugin-advanced-emoji 1.2 配置 { \"plugins\" : [\"advanced-emoji\"] } 1.3 效果 People :bowtie: :smile: :laughing: :blush: :smiley: :relaxed: :smirk: :heart_eyes: :kissing_heart: :kissing_closed_eyes: :flushed: :relieved: :satisfied: :grin: :wink: :stuck_out_tongue_winking_eye: :stuck_out_tongue_closed_eyes: :grinning: :kissing: :kissing_smiling_eyes: :stuck_out_tongue: :sleeping: :worried: :frowning: :anguished: :open_mouth: :grimacing: :confused: :hushed: :expressionless: :unamused: :sweat_smile: :sweat: :disappointed_relieved: :weary: :pensive: :disappointed: :confounded: :fearful: :cold_sweat: :persevere: :cry: :sob: :joy: :astonished: :scream: :neckbeard: :tired_face: :angry: :rage: :triumph: :sleepy: :yum: :mask: :sunglasses: :dizzy_face: :imp: :smiling_imp: :neutral_face: :no_mouth: :innocent: :alien: :yellow_heart: :blue_heart: :purple_heart: :heart: :green_heart: :broken_heart: :heartbeat: :heartpulse: :two_hearts: :revolving_hearts: :cupid: :sparkling_heart: :sparkles: :star: :star2: :dizzy: :boom: :collision: :anger: :exclamation: :question: :grey_exclamation: :grey_question: :zzz: :dash: :sweat_drops: :notes: :musical_note: :fire: :hankey: :poop: :shit: :+1: :thumbsup: :-1: :thumbsdown: :ok_hand: :punch: :facepunch: :fist: :v: :wave: :hand: :raised_hand: :open_hands: :point_up: :point_down: :point_left: :point_right: :raised_hands: :pray: :point_up_2: :clap: :muscle: :metal: :fu: :walking: :runner: :running: :couple: :family: :two_men_holding_hands: :two_women_holding_hands: :dancer: :dancers: :ok_woman: :no_good: :information_desk_person: :raising_hand: :bride_with_veil: :person_with_pouting_face: :person_frowning: :bow: :couplekiss: :couple_with_heart: :massage: :haircut: :nail_care: :boy: :girl: :woman: :man: :baby: :older_woman: :older_man: :person_with_blond_hair: :man_with_gua_pi_mao: :man_with_turban: :construction_worker: :cop: :angel: :princess: :smiley_cat: :smile_cat: :heart_eyes_cat: :kissing_cat: :smirk_cat: :scream_cat: :crying_cat_face: :joy_cat: :pouting_cat: :japanese_ogre: :japanese_goblin: :see_no_evil: :hear_no_evil: :speak_no_evil: :guardsman: :skull: :feet: :lips: :kiss: :droplet: :ear: :eyes: :nose: :tongue: :love_letter: :bust_in_silhouette: :busts_in_silhouette: :speech_balloon: :thought_balloon: :feelsgood: :finnadie: :goberserk: :godmode: :hurtrealbad: :rage1: :rage2: :rage3: :rage4: :suspect: :trollface: Nature :sunny: :umbrella: :cloud: :snowflake: :snowman: :zap: :cyclone: :foggy: :ocean: :cat: :dog: :mouse: :hamster: :rabbit: :wolf: :frog: :tiger: :koala: :bear: :pig: :pig_nose: :cow: :boar: :monkey_face: :monkey: :horse: :racehorse: :camel: :sheep: :elephant: :panda_face: :snake: :bird: :baby_chick: :hatched_chick: :hatching_chick: :chicken: :penguin: :turtle: :bug: :honeybee: :ant: :beetle: :snail: :octopus: :tropical_fish: :fish: :whale: :whale2: :dolphin: :cow2: :ram: :rat: :water_buffalo: :tiger2: :rabbit2: :dragon: :goat: :rooster: :dog2: :pig2: :mouse2: :ox: :dragon_face: :blowfish: :crocodile: :dromedary_camel: :leopard: :cat2: :poodle: :paw_prints: :bouquet: :cherry_blossom: :tulip: :four_leaf_clover: :rose: :sunflower: :hibiscus: :maple_leaf: :leaves: :fallen_leaf: :herb: :mushroom: :cactus: :palm_tree: :evergreen_tree: :deciduous_tree: :chestnut: :seedling: :blossom: :ear_of_rice: :shell: :globe_with_meridians: :sun_with_face: :full_moon_with_face: :new_moon_with_face: :new_moon: :waxing_crescent_moon: :first_quarter_moon: :waxing_gibbous_moon: :full_moon: :waning_gibbous_moon: :last_quarter_moon: :waning_crescent_moon: :last_quarter_moon_with_face: :first_quarter_moon_with_face: :moon: :moon: :earth_africa: :earth_americas: :earth_asia: :volcano: :milky_way: :partly_sunny: :octocat: :squirrel: Objects :bamboo: :gift_heart: :dolls: :school_satchel: :mortar_board: :flags: :fireworks: :sparkler: :wind_chime: :rice_scene: :jack_o_lantern: :ghost: :santa: :christmas_tree: :gift: :bell: :no_bell: :tanabata_tree: :tada: :confetti_ball: :balloon: :crystal_ball: :cd: :dvd: :floppy_disk: :camera: :video_camera: :movie_camera: :computer: :tv: :iphone: :phone: :telephone: :telephone_receiver: :pager: :fax: :minidisc: :vhs: :sound: :speaker: :mute: :loudspeaker: :mega: :hourglass: :hourglass_flowing_sand: :alarm_clock: :watch: :radio: :satellite: :loop: :mag: :mag_right: :unlock: :lock: :lock_with_ink_pen: :closed_lock_with_key: :key: :bulb: :flashlight: :high_brightness: :low_brightness: :electric_plug: :battery: :calling: :email: :mailbox: :postbox: :bath: :bathtub: :shower: :toilet: :wrench: :nut_and_bolt: :hammer: :seat: :moneybag: :yen: :dollar: :pound: :euro: :credit_card: :money_with_wings: :e-mail: :inbox_tray: :outbox_tray: :envelope: :incoming_envelope: :postal_horn: :mailbox_closed: :mailbox_with_mail: :mailbox_with_no_mail: :door: :smoking: :bomb: :gun: :hocho: :pill: :syringe: :page_facing_up: :page_with_curl: :bookmark_tabs: :bar_chart: :chart_with_upwards_trend: :chart_with_downwards_trend: :scroll: :clipboard: :calendar: :date: :card_index: :file_folder: :open_file_folder: :scissors: :pushpin: :paperclip: :black_nib: :pencil2: :straight_ruler: :triangular_ruler: :closed_book: :green_book: :blue_book: :orange_book: :notebook: :notebook_with_decorative_cover: :ledger: :books: :bookmark: :name_badge: :microscope: :telescope: :newspaper: :football: :basketball: :soccer: :baseball: :tennis: :8ball: :rugby_football: :bowling: :golf: :mountain_bicyclist: :bicyclist: :horse_racing: :snowboarder: :swimmer: :surfer: :ski: :spades: :hearts: :clubs: :diamonds: :gem: :ring: :trophy: :musical_score: :musical_keyboard: :violin: :space_invader: :video_game: :black_joker: :flower_playing_cards: :game_die: :dart: :mahjong: :clapper: :memo: :pencil: :book: :art: :microphone: :headphones: :trumpet: :saxophone: :guitar: :shoe: :sandal: :high_heel: :lipstick: :boot: :shirt: :tshirt: :necktie: :womans_clothes: :dress: :running_shirt_with_sash: :jeans: :kimono: :bikini: :ribbon: :tophat: :crown: :womans_hat: :mans_shoe: :closed_umbrella: :briefcase: :handbag: :pouch: :purse: :eyeglasses: :fishing_pole_and_fish: :coffee: :tea: :sake: :baby_bottle: :beer: :beers: :cocktail: :tropical_drink: :wine_glass: :fork_and_knife: :pizza: :hamburger: :fries: :poultry_leg: :meat_on_bone: :spaghetti: :curry: :fried_shrimp: :bento: :sushi: :fish_cake: :rice_ball: :rice_cracker: :rice: :ramen: :stew: :oden: :dango: :egg: :bread: :doughnut: :custard: :icecream: :ice_cream: :shaved_ice: :birthday: :cake: :cookie: :chocolate_bar: :candy: :lollipop: :honey_pot: :apple: :green_apple: :tangerine: :lemon: :cherries: :grapes: :watermelon: :strawberry: :peach: :melon: :banana: :pear: :pineapple: :sweet_potato: :eggplant: :tomato: :corn: Places :house: :house_with_garden: :school: :office: :post_office: :hospital: :bank: :convenience_store: :love_hotel: :hotel: :wedding: :church: :department_store: :european_post_office: :city_sunrise: :city_sunset: :japanese_castle: :european_castle: :tent: :factory: :tokyo_tower: :japan: :mount_fuji: :sunrise_over_mountains: :sunrise: :stars: :statue_of_liberty: :bridge_at_night: :carousel_horse: :rainbow: :ferris_wheel: :fountain: :roller_coaster: :ship: :speedboat: :boat: :sailboat: :rowboat: :anchor: :rocket: :airplane: :helicopter: :steam_locomotive: :tram: :mountain_railway: :bike: :aerial_tramway: :suspension_railway: :mountain_cableway: :tractor: :blue_car: :oncoming_automobile: :car: :red_car: :taxi: :oncoming_taxi: :articulated_lorry: :bus: :oncoming_bus: :rotating_light: :police_car: :oncoming_police_car: :fire_engine: :ambulance: :minibus: :truck: :train: :station: :train2: :bullettrain_front: :bullettrain_side: :light_rail: :monorail: :railway_car: :trolleybus: :ticket: :fuelpump: :vertical_traffic_light: :traffic_light: :warning: :construction: :beginner: :atm: :slot_machine: :busstop: :barber: :hotsprings: :checkered_flag: :crossed_flags: :izakaya_lantern: :moyai: :circus_tent: :performing_arts: :round_pushpin: :triangular_flag_on_post: :jp: :kr: :cn: :us: :fr: :es: :it: :ru: :gb: :uk: :de: Symbols :one: :two: :three: :four: :five: :six: :seven: :eight: :nine: :keycap_ten: :1234: :zero: :hash: :symbols: :arrow_backward: :arrow_down: :arrow_forward: :arrow_left: :capital_abcd: :abcd: :abc: :arrow_lower_left: :arrow_lower_right: :arrow_right: :arrow_up: :arrow_upper_left: :arrow_upper_right: :arrow_double_down: :arrow_double_up: :arrow_down_small: :arrow_heading_down: :arrow_heading_up: :leftwards_arrow_with_hook: :arrow_right_hook: :left_right_arrow: :arrow_up_down: :arrow_up_small: :arrows_clockwise: :arrows_counterclockwise: :rewind: :fast_forward: :information_source: :ok: :twisted_rightwards_arrows: :repeat: :repeat_one: :new: :top: :up: :cool: :free: :ng: :cinema: :koko: :signal_strength: :u5272: :u5408: :u55b6: :u6307: :u6708: :u6709: :u6e80: :u7121: :u7533: :u7a7a: :u7981: :sa: :restroom: :mens: :womens: :baby_symbol: :no_smoking: :parking: :wheelchair: :metro: :baggage_claim: :accept: :wc: :potable_water: :put_litter_in_its_place: :secret: :congratulations: :m: :passport_control: :left_luggage: :customs: :ideograph_advantage: :cl: :sos: :id: :no_entry_sign: :underage: :no_mobile_phones: :do_not_litter: :non-potable_water: :no_bicycles: :no_pedestrians: :children_crossing: :no_entry: :eight_spoked_asterisk: :eight_pointed_black_star: :heart_decoration: :vs: :vibration_mode: :mobile_phone_off: :chart: :currency_exchange: :aries: :taurus: :gemini: :cancer: :leo: :virgo: :libra: :scorpius: :sagittarius: :capricorn: :aquarius: :pisces: :ophiuchus: :six_pointed_star: :negative_squared_cross_mark: :a: :b: :ab: :o2: :diamond_shape_with_a_dot_inside: :recycle: :end: :on: :soon: :clock1: :clock130: :clock10: :clock1030: :clock11: :clock1130: :clock12: :clock1230: :clock2: :clock230: :clock3: :clock330: :clock4: :clock430: :clock5: :clock530: :clock6: :clock630: :clock7: :clock730: :clock8: :clock830: :clock9: :clock930: :heavy_dollar_sign: :copyright: :registered: :tm: :x: :heavy_exclamation_mark: :bangbang: :interrobang: :o: :heavy_multiplication_x: :heavy_plus_sign: :heavy_minus_sign: :heavy_division_sign: :white_flower: :100: :heavy_check_mark: :ballot_box_with_check: :radio_button: :link: :curly_loop: :wavy_dash: :part_alternation_mark: :trident: :black_square: :white_square: :white_square: :white_check_mark: :black_square_button: :white_square_button: :black_circle: :white_circle: :red_circle: :large_blue_circle: :large_blue_diamond: :large_orange_diamond: :small_blue_diamond: :small_orange_diamond: :small_red_triangle: :small_red_triangle_down: :shipit: 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitbook/Plugins/1_plugin_Emoji.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/Plugins/1_plugin_Emoji.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/Plugins/1_plugin_Emoji.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitbook/1_gitbook_start.html":{"url":"Gitbook/1_gitbook_start.html","title":"gitbook 快速入门","keywords":"","body":" Gitbook 快速入门1. 介绍2. 条件3. 安装 gitbook工具4. 创建gitbook书籍5. SUMMARY.md6. README.md7. book.jsonGitbook 快速入门 1. 介绍 Gitbook 是一款优秀的 基于 Node.js 的开源文档管理工具，具有丰富的开源插件。 GitBook 支持 Markdown 和 AsciiDoc 两种语法格式，能够输出 html，pdf，epub，mobi 等多种格式。 2. 条件 nodejs 安装 node一定要安装10.X版本，否则报如下错误： CLI version: 2.3.2 Installing GitBook 3.2.3 /usr/local/node/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/node/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:193:5) 系统：ubuntu：18.04 3. 安装 gitbook工具 $ npm install gitbook-cli -g /usr/local/node/bin/gitbook -> /usr/local/node/lib/node_modules/gitbook-cli/bin/gitbook.js + gitbook-cli@2.3.2 added 578 packages from 672 contributors in 191.662s #找到gitbook命令位置 $ ls /usr/local/node-v10.24.0-linux-x64/bin/ gitbook node node_modules/ npm npx package-lock.json #添加软连接 $ ln -s /usr/local/node-v17.4.0-linux-x64/bin/gitbook /usr/local/bin/ $ gitbook -V CLI version: 2.3.2 Installing GitBook 3.2.3 gitbook@3.2.3 ../../../../tmp/tmp-117466TKiRhUq3ov0O/node_modules/gitbook ├── escape-html@1.0.3 ├── escape-string-regexp@1.0.5 ├── destroy@1.0.4 ├── ignore@3.1.2 ├── bash-color@0.0.4 ├── gitbook-plugin-livereload@0.0.1 ├── cp@0.2.0 ├── nunjucks-do@1.0.0 ├── graceful-fs@4.1.4 ├── github-slugid@1.0.1 ├── direction@0.1.5 ├── q@1.4.1 ├── spawn-cmd@0.0.2 ├── gitbook-plugin-fontsettings@2.0.0 ├── open@0.0.5 ├── is@3.3.0 ├── object-path@0.9.2 ├── extend@3.0.2 ├── json-schema-defaults@0.1.1 ├── gitbook-plugin-search@2.2.1 ├── jsonschema@1.1.0 ├── crc@3.4.0 ├── urijs@1.18.0 ├── semver@5.1.0 ├── immutable@3.8.2 ├── front-matter@2.3.0 ├── npmi@2.0.1 (semver@4.3.6) ├── resolve@1.1.7 ├── gitbook-plugin-theme-default@1.0.7 ├── moment@2.13.0 ├── npm@3.9.2 ├── dom-serializer@0.1.0 (domelementtype@1.1.3, entities@1.1.2) ├── tmp@0.0.28 (os-tmpdir@1.0.2) ├── error@7.0.2 (xtend@4.0.2, string-template@0.2.1) ├── omit-keys@0.1.0 (isobject@0.2.0, array-difference@0.0.1) ├── mkdirp@0.5.1 (minimist@0.0.8) ├── js-yaml@3.14.1 (esprima@4.0.1, argparse@1.0.10) ├── gitbook-plugin-lunr@1.2.0 (html-entities@1.2.0, lunr@0.5.12) ├── gitbook-plugin-highlight@2.0.2 (highlight.js@9.2.0) ├── gitbook-plugin-sharing@1.0.2 (lodash@3.10.1) ├── i18n-t@1.0.1 (lodash@4.17.21) ├── gitbook-markdown@1.3.2 (kramed-text-renderer@0.2.1, gitbook-html@1.3.3, kramed@0.5.6, lodash@4.17.21) ├── gitbook-asciidoc@1.2.2 (gitbook-html@1.3.3, asciidoctor.js@1.5.5-1, lodash@4.17.21) ├── send@0.13.2 (fresh@0.3.0, etag@1.7.0, statuses@1.2.1, range-parser@1.0.3, ms@0.7.1, depd@1.1.2, mime@1.3.4, debug@2.2.0, http-errors@1.3.1, on-finished@2.3.0) ├── fresh-require@1.0.3 (is-require@0.0.1, shallow-copy@0.0.1, astw@1.3.0, acorn@0.9.0, sleuth@0.1.1, escodegen@1.14.3, through2@0.6.5) ├── rmdir@1.2.0 (node.flow@1.2.3) ├── request@2.72.0 (tunnel-agent@0.4.3, aws-sign2@0.6.0, forever-agent@0.6.1, oauth-sign@0.8.2, is-typedarray@1.0.0, caseless@0.11.0, stringstream@0.0.6, aws4@1.11.0, isstream@0.1.2, json-stringify-safe@5.0.1, tough-cookie@2.2.2, node-uuid@1.4.8, qs@6.1.2, hawk@3.1.3, combined-stream@1.0.8, mime-types@2.1.34, http-signature@1.1.1, form-data@1.0.1, bl@1.1.2, har-validator@2.0.6) ├── read-installed@4.0.3 (debuglog@1.0.1, util-extend@1.0.3, slide@1.1.6, readdir-scoped-modules@1.1.0, read-package-json@2.1.2) ├── cpr@1.1.1 (rimraf@2.4.5) ├── tiny-lr@0.2.1 (parseurl@1.3.3, livereload-js@2.4.0, qs@5.1.0, debug@2.2.0, faye-websocket@0.10.0, body-parser@1.14.2) ├── cheerio@0.20.0 (entities@1.1.2, lodash@4.17.21, css-select@1.2.0, htmlparser2@3.8.3, jsdom@7.2.2) ├── juice@2.0.0 (deep-extend@0.4.2, slick@1.12.2, batch@0.5.3, cssom@0.3.1, cross-spawn-async@2.2.5, commander@2.9.0, web-resource-inliner@2.0.0) ├── chokidar@1.5.0 (async-each@1.0.3, path-is-absolute@1.0.1, inherits@2.0.4, glob-parent@2.0.0, is-glob@2.0.1, is-binary-path@1.0.1, anymatch@1.3.2, readdirp@2.2.1) └── nunjucks@2.5.2 (asap@2.0.6, yargs@3.32.0, chokidar@1.7.0) GitBook version: 3.2.3 4. 创建gitbook书籍 $ mkdir gitbook-demo $ cd gitbook-demo #使用 gitbook init 初始化书籍目录 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished $ ls README.md SUMMARY.md #使用 gitbook build 编译书籍 $ gitbook build info: 7 plugins are installed info: 6 explicitly listed info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.4s ! $ ls _book README.md SUMMARY.md $ ls _book/ gitbook index.html search_index.json $ ls _book/gitbook/ fonts gitbook.js gitbook-plugin-fontsettings gitbook-plugin-highlight gitbook-plugin-lunr gitbook-plugin-search gitbook-plugin-sharing images style.css theme.js #使用 gitbook serve 编译并预览书籍 $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.5s ! Starting server ... Serving book on http://localhost:4000 效果 图中侧栏Introduction的内容正是README.md的内容，SUMMARY.md 是编写界面侧栏的目录结构。 $ cat README.md # Introduction $ cat SUMMARY.md # Summary * [Introduction](README.md) 5. SUMMARY.md GitBook 使用文件 SUMMARY.md 来定义书本的章节和子章节的结构。文件 SUMMARY.md 被用来生成书本内容的预览表。 SUMMARY.md 的格式是一个简单的链接列表，链接的名字是章节的名字，链接的指向是章节文件的路径。子章节被简单的定义为一个内嵌于父章节的列表。以 # 开头的行为注释被忽略。 GitBook使用一个SUMMARY.md文件来定义文档的菜单。 虽说在官方文档中，它是可选的，但是它相当重要，控制了左边菜单栏的显示内容。它通过 Markdown 中的列表语法来表示文件的父子关系。紧凑型的。 创建一个目录，并编写一个markdown格式的文档 $ mkdir git $ mv git_training.md git $ ls _book book.json book.json_bak git kubernetes node_modules README.md SUMMARY.md $ ls git/ 1_git_introduce.md 2_git_command.md 编写SUMMARY.md # Summary ## 前言 * [Introduction](README.md) ## git * [git 介绍](git/1_git_introduce.md) * [git 命令](git/2_git_training.md) 启动 $ gitbook serve 效果： 当 md 文件数量非常多时，我们可以利用 插件 summary 自动生成菜单 summary 文件的介绍。 6. README.md 书本的首页内容默认是从文件 README.md 中提取的。 README.md是 gitbook 最基础的文件之一，它一般用来描述这本书最基本的信息。 它呈现给读者这本书最初的样子，如果内容不够简洁明了，很可能就没有看下去的欲望了。 可以通过 gitbook init 自动创建该文件。 如果这个文件名没有出现在 SUMMARY.md (目录索引文件) 中，那么它会被添加为章节的第一个条目。 如何替代README.md 一些项目更愿意将 README.md 文件作为项目的介绍而不是书的介绍。 大部分代码托管平台将 README.md 自动显示到项目首页，如果你不喜欢这样。 从GitBook >2.0.0 起，就可以在 book.json 中定义某个文件作为README。 删除掉SUMMARY.md文档关于README.md的引用 编写information.md $ cat information.md --- 这是一本关于介绍git、github、gitlab、gitbook的书籍。 比起官方的理解，它更接近体验训练。 book.json添加structure参数 book.json { \"structure\" : { \"readme\" : \"information.md\" } } 启动 $ gitbook serve 效果：默认的首页 7. book.json 7.1 侧栏添加链接 $ ls _book book.json kubernetes README.md SUMMARY.md $ vim book.json { \"author\": \"zongxun \", \"description\": \"This is a sample book created by gitbook\", \"extension\": null, \"generator\": \"site\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"Blog\": \"https://blog.csdn.net/xixihahalelehehe?spm=1000.2115.3001.5343\" } }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [], \"title\": \"GitBook Handbook\", \"variables\": {} } $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.5s ! Starting server ... Serving book on http://localhost:4000 效果，只看到了一个Blog链接。 7.2 添加一个插件 编写book.json添加新theme-comscore主题插件 $ cat book.json { \"author\": \"zongxun \", \"description\": \"This is a sample book created by gitbook\", \"extension\": null, \"generator\": \"site\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"Blog\": \"https://blog.csdn.net/xixihahalelehehe?spm=1000.2115.3001.5343\" } }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [ \"theme-comscore\" ], \"title\": \"GitBook Handbook\", \"variables\": {} } 安装插件 gitbook install info: installing 1 plugins using npm@3.9.2 info: info: installing plugin \"theme-comscore\" info: install plugin \"theme-comscore\" (*) from NPM with version 0.0.3 /root/github/gitbook-demo └── gitbook-plugin-theme-comscore@0.0.3 info: >> plugin \"theme-comscore\" installed with success 执行 $ gitbook serve 添加主题插件前： 添加主题插件后： 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitbook/1_gitbook_start.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/1_gitbook_start.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitbook/1_gitbook_start.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitlab/":{"url":"Gitlab/","title":"Gitlab","keywords":"","body":" Gitlab1. 简介2. 历史3. 特征3.1 优点3.2 缺点Gitlab 1. 简介 Gitlab 是一个开源的Git代码仓库系统，可以实现自托管的Github项目，即用于构建私有的代码托管平台和项目管理系统。系统基于Ruby on Rails开发，速度快、安全稳定。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 2. 历史 GitLab 由Dmitriy Zaporozhets和Valery Sizov于 2011 年 10 月发现。 它是在 MIT 许可下分发的，GitLab 的稳定版本是 10.4，于 2018 年 1 月 22 日发布。 3. 特征 GitLab 免费托管您的（私人）软件项目。 GitLab 是一个管理 Git 存储库的平台。 GitLab 提供免费的公共和私有存储库、问题跟踪和 wiki。 GitLab 是一个在 Git 之上的用户友好的 Web 界面层，它提高了使用 Git 的速度。 GitLab 提供了自己的持续集成(CI) 系统来管理项目，并提供用户界面以及 GitLab 的其他功能。 3.1 优点 GitLab 提供GitLab Community Edition版本供用户定位，他们的代码存在于哪些服务器上。 GitLab 免费提供无限数量的私有和公共存储库。 该片段部分可以从一个项目共享，而不是共享整个项目的代码量小。 3.2 缺点 在推送和拉取存储库时，它不如 GitHub 快。 GitLab 界面在从一个页面切换到另一个页面时需要一些时间。 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitlab/ 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/README.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitlab/3_gitlab_config.html":{"url":"Gitlab/3_gitlab_config.html","title":"gitlab 配置","keywords":"","body":" gitlab 配置1. 邮箱发送短信2. 注册账号3. 创建项目3.1 创建空白项目3.2 创建模板项目3.3 导入项目4. 删除项目5. gitlab项目上传githubgitlab 配置 相关阅读： 部署gitlab gitlab-runner部署 Gitlab 基础配置 Create a Continuous Integration (CI) Pipeline in Gitlab git与gitlab快速学习手册 1. 邮箱发送短信 $ docker exec -ti gitlab bash $ vi /etc/gitlab/gitlab.rb gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = \"smtp-mail.outlook.com\" gitlab_rails['smtp_port'] = 25 gitlab_rails['smtp_user_name'] = \"@outlook.com\" gitlab_rails['smtp_password'] = \"\" gitlab_rails['smtp_domain'] = \"outlook.com\" gitlab_rails['smtp_authentication'] = \"login\" gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = false gitlab_rails['gitlab_email_enabled'] = true gitlab_rails['gitlab_email_from'] = '@outlook.com' gitlab_rails['gitlab_email_display_name'] = 'Gitlab' 保存退出修改，执行命令gitlab-ctl reconfigure重新配置gitlab $ gitlab-ctl reconfigure 执行命令gitlab-ctl console测试发邮件，进入控制台之后执行命令 Notify.test_email('@139.com', '邮件标题', '邮件正文').deliver_now irb(main):001:0> Notify.test_email('@139.com', '邮件标题', '邮件正文').deliver_now Delivered mail 61b9f42db6726_4fc5a503772f@gitlab.example.com.mail (3732.4ms) => #, >, >, , >, , , , , , > 2. 注册账号 填写自己的名字、邮箱、密码 注册后等待管理员验证通过。 登陆管理员，找到Admin 找到管理user的界面 发现新注册的用户 点击通过或拒绝。 通过后，你也可以对此用户进行限制访问或删除。 通过后，租户登陆，选择用户角色 创建项目或寻找项目 与管理员界面的区别缺少admin的权限 回到管理员的user用户管理界面，发现xiaoming已经被激活。 3. 创建项目 第一种 第二种 第三种 三类项目 空白项目，导入项目，模板项目 3.1 创建空白项目 当我们在点击创建之前，如果点击了“README”，如下 那创建出来的项目是这样的。 3.2 创建模板项目 当我们选择模板项目时，会有需要各类开发的模板项目供我们选择。 这个关于kubernets的gitbook项目 我们可以编写自己的gitbook了。 3.3 导入项目 导入项目，适合以下场景： 项目迁移 借用开源项目定制开发 我们需要一个token,这个token来自于你选择的平台，而不是来自自己的gitlab平台，我这选择了github平台。 我们现在去创建token，我们 登陆github，选择设置“setting” 找到“developer settings” 根据兴趣随便取 我们创建出来了 复制到gitlab的这里 获取到我的github账号下的项目列表，选择其中一个 开始导入 导入完成。 查看gitlab导入的项目 查看项目内容，然后根据自己的需求开发属于你自己的项目吧。 4. 删除项目 我们要删除这个项目 再次确认 我们找不到了gitlab-example-demo了 5. gitlab项目上传github github创建一个空项目 $ git clone http://gitlab.example.com:8081/root/gitlab-example-demo.git $ cd gitlab-example-demo $ git remote -v origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (fetch) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (push) $ git remote add hello https://github.com/Ghostwritten/gitlab-example-demo.git root@yourdomain:/data/gitlab/projects/gitlab-example-demo# git remote -v hello https://github.com/Ghostwritten/gitlab-example-demo.git (fetch) hello https://github.com/Ghostwritten/gitlab-example-demo.git (push) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (fetch) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (push) $ git push -u hello Username for 'https://github.com': ghostwritten Password for 'https://ghostwritten@github.com': Counting objects: 24, done. Delta compression using up to 4 threads. Compressing objects: 100% (22/22), done. Writing objects: 100% (24/24), 2.36 KiB | 201.00 KiB/s, done. Total 24 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), done. To https://github.com/Ghostwritten/gitlab-example-demo.git * [new branch] master -> master Branch 'master' set up to track remote branch 'master' from 'hello'. 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitlab/3_gitlab_config.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/3_gitlab_config.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/3_gitlab_config.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitlab/5_gitlab_runner_management.html":{"url":"Gitlab/5_gitlab_runner_management.html","title":"gitlab runner 管理","keywords":"","body":" gitlab-runner 管理快速构建.gitlab-ci.yamlpython demo ci推送项目至gitlab安装gitlab-runner选择一个本地部署的需求gitlab-runner 管理 更多阅读： 部署gitlab gitlab-runner部署 Gitlab 基础配置 Create a Continuous Integration (CI) Pipeline in Gitlab git与gitlab快速学习手册 快速构建.gitlab-ci.yaml 创建一个项目 创建一个模板.gitlab-ci.yaml 选择Getting-started模板 stages: # List of stages for jobs, and their order of execution - build - test - deploy build-job: # This job runs in the build stage, which runs first. stage: build script: - echo \"Compiling the code...\" - echo \"Compile complete.\" unit-test-job: # This job runs in the test stage. stage: test # It only starts when the job in the build stage completes successfully. script: - echo \"Running unit tests... This will take about 60 seconds.\" - sleep 60 - echo \"Code coverage is 90%\" lint-test-job: # This job also runs in the test stage. stage: test # It can run at the same time as unit-test-job (in parallel). script: - echo \"Linting code... This will take about 10 seconds.\" - sleep 10 - echo \"No lint issues found.\" deploy-job: # This job runs in the deploy stage. stage: deploy # It only runs when *both* jobs in the test stage complete successfully. script: - echo \"Deploying application...\" - echo \"Application successfully deployed.\" 全部正常。 我们充分利用模板文件，可以为我们节省大量的时间。 python demo ci 使用flask快速搭建website 推送项目至gitlab 记录模块清单 pip freeze > requestments.txt git init git add . git commit -m \"add a new python demo\" git remote add origin root@gitlab.example.com:8081/root/flask_web1.git git push 安装gitlab-runner docker run -d --name gitlab-runner --restart always --net=host \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 选择一个本地部署的需求 我们就要为该项目注册shell运行的执行器的runner $ docker run --rm --net=host -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v14.4.2 register Runtime platform arch=amd64 os=linux pid=7 revision=50fc80a6 version=14.4.2 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): http://gitlab.example.com:8081 Enter the registration token: 8BxfhdBE2zf8NioR1UFE Enter a description for the runner: [yourdomain.com]: flask_demo Enter tags for the runner (comma-separated): python Registering runner... succeeded runner=8BxfhdBE Enter an executor: custom, parallels, docker+machine, kubernetes, docker, docker-ssh, shell, ssh, virtualbox, docker-ssh+machine: shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 查看配置 $ cat /srv/gitlab-runner/config/config.toml concurrent = 1 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"demo\" url = \"http://gitlab.example.com:8081/\" token = \"PF41kT9ZV_1DoT6VzcCu\" executor = \"docker\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] [runners.docker] tls_verify = false image = \"ubuntu:20.04\" dns = [\"8.8.8.8\", \"1.1.1.1\"] privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\"] extra_hosts = [\"gitlab.example.com:192.168.211.70\"] shm_size = 0 .......... [[runners]] name = \"flask_demo\" url = \"http://gitlab.example.com:8081\" token = \"tvCxfurs7EmRApH7un2a\" executor = \"shell\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 为此项目注册runner，并不会影响其他项目的项目，因为配置是追加的。 选择一个最接近你的需求的、并修改量小的.gitlab-ci.yaml模板 修改.gitlab-ci.yaml 我的本地环境是ubuntu:8.04,本地可能没有flask，所以要在.gitlab-ci.yaml,装完就可以部署，两步走，即两个stage。 .gitlab-ci.yaml stages: - dep # List of stages for jobs, and their order of execution - deploy dep-job: stage: dep script: - apt -y install python3-pip - pip3 install flask deploy-job: # This job runs in the deploy stage. stage: deploy # It only runs when *both* jobs in the test stage complete successfully. script: - echo \"Deploying python flask demo application...\" - python3 app.py\" 创建一个Dockerfile模板 修改Dockerfile 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitlab/5_gitlab_runner_management.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/5_gitlab_runner_management.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/5_gitlab_runner_management.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitlab/4_gitlab_runner_deploy.html":{"url":"Gitlab/4_gitlab_runner_deploy.html","title":"gitlab runner 部署","keywords":"","body":" gitlab-runner 部署1. 本地安装gitlab-runner2. 项目通过本地命令注册runner3. docker安装gitlab-runner4. 项目通过docker注册runner5. 注意gitlab-runner 部署 1. 本地安装gitlab-runner $ wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 $ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash $ yum install gitlab-runner $ systemctl status gitlab-runner $ sudo chown -R gitlab-runner:gitlab-runner /var/run/docker.sock $ sudo su - gitlab-runner 当然，我们可以安装官方的方法安装，从gitlab就可以找到简洁的安装方式： 2. 项目通过本地命令注册runner 1 输入如下命令 $ sudo gitlab-runner register 2 输入gitlab地址 地址可以从项目中获取到 这个页面会获取到地址和token，下面用到 3 输入token，就是截图里的token 4 输入对Runner的描述，这个在GitLab’s UI可以修改，比如my-runner 5 给Runner打个标签，这个在GitLab’s UI可以修改，比如java 6 是否Runner执行没有标签的构建任务，输入true 7 是否将Runner锁定到当前项目，这个在GitLab’s UI可以修改，输入true 8 输入Runner的执行者，这里我选择shell 这样我们就配置好了Runner 当我们有代码提交的时候，Runner就会执行.gitlab-ci.yml的构建任务 3. docker安装gitlab-runner docker run -d --name gitlab-runner --restart always --net=host \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 您可以使用配置容器来挂载您的自定义数据卷 docker volume create gitlab-runner-config docker run -d --name gitlab-runner --restart always --net=host \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v gitlab-runner-config:/etc/gitlab-runner \\ gitlab/gitlab-runner:latest 4. 项目通过docker注册runner $ docker run --rm --net=host -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v14.4.2 register Runtime platform arch=amd64 os=linux pid=7 revision=50fc80a6 version=14.4.2 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): http://192.168.211.70:8081 Enter the registration token: 6D5mo8iWCLBaVdqcaqjN Enter a description for the runner: [329b671ffa00]: gitlab-example Enter tags for the runner (comma-separated): Registering runner... succeeded runner=6D5mo8iW Enter an executor: ssh, virtualbox, docker+machine, shell, docker-ssh+machine, kubernetes, custom, docker, docker-ssh, parallels: docker Enter the default Docker image (for example, ruby:2.6): ubuntu:20.04 Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 我们选择的执行器是docker，那么关于这个项目，编写.gitlab-ci.yml就要一定docker执行的规则去执行。 注册配置内容我可以在这里看到。并根据需求做一些小的变动。 $ docker exec -ti gitlab-runner bash $ cat /etc/gitlab-runner/config.toml concurrent = 1 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] [[runners]] name = \"demo\" url = \"http://gitlab.example.com:8081/\" token = \"PF41kT9ZV_1DoT6VzcCu\" #这里的token，并不是registration token的token。 executor = \"docker\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] [runners.docker] extra_hosts = [\"gitlab.example.com:192.168.211.70\"] tls_verify = false image = \"ubuntu:20.04\" privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\"] shm_size = 0 dns = [\"8.8.8.8\", \"1.1.1.1\"] 执行器选择是多种样的，我们当然也可以多个选择。通过多次注册的方式。 我尝试再次注册一次。 docker run --net=host --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v14.4.2 register Runtime platform arch=amd64 os=linux pid=11 revision=50fc80a6 version=14.4.2 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): http://gitlab.example.com:8081 Enter the registration token: 6D5mo8iWCLBaVdqcaqjN Enter a description for the runner: [yourdomain.com]: gitlab-demo Enter tags for the runner (comma-separated): gitlab-demo-shell Registering runner... succeeded runner=6D5mo8iW Enter an executor: docker, docker-ssh, shell, docker+machine, custom, parallels, ssh, virtualbox, docker-ssh+machine, kubernetes: shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 这次的执行器是shell。 登陆gitlab查看runner的列表，多出一个runner 查看runner配置 $ docker exec -ti gitlab-runner bash $ cat /etc/gitlab-runner/config.toml concurrent = 1 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"\" url = \"\" token = \"\" executor = \"\" [[runners]] name = \"demo\" url = \"http://gitlab.example.com:8081/\" token = \"PF41kT9ZV_1DoT6VzcCu\" executor = \"docker\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] [runners.docker] tls_verify = false image = \"ubuntu:20.04\" dns = [\"8.8.8.8\", \"1.1.1.1\"] privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\"] extra_hosts = [\"gitlab.example.com:192.168.211.70\"] shm_size = 0 [[runners]] name = \"gitlab-demo\" url = \"http://gitlab.example.com:8081\" token = \"TX1s_ZQ1RnNj5xaVW-y9\" executor = \"shell\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 关于一个项目我们通过多次注册编排，选择不同执行器编排.gitlab-ci.yml,比如，你可能需要这个应用暂时本地运行，后来docker运行，再后来kubernets运行等等。 5. 注意 不同的项目向runner注册的token是不一样的。 我们可以在根据自己的业务应用需求在多个机器运行多个gitlab-runner。 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitlab/4_gitlab_runner_deploy.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/4_gitlab_runner_deploy.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/4_gitlab_runner_deploy.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitlab/1_gitlab_start.html":{"url":"Gitlab/1_gitlab_start.html","title":"gitlab 开始","keywords":"","body":" gitlab 开始1. 前提2. 安装gitlab3. 配置gitlab4. 启动gitlab5. GitLab构成5.1 gitlab shell5.2 gitlab workhorse6. gitlab 命令7. gitlab主要目录8. gitlab 仓库管理9. 创建用户create user10. 用户授权（grant user）11. 创建仓库create project12. 配置ssh key13. 推送本地客户端仓库到gitlab14. 克隆gitlab仓库到本地客户端15. 设置分支保护16. Gitlab的备份、恢复、升级16.1 手动备份16.2 定时备份输入命令crontab -e16.3 恢复实践gitlab 开始 1. 前提 jenkins插件地址： http://updates.jenkins-ci.org/download/plugins/ 192.168.211.90 gitlab、jenkins、Maven 192.168.211.91 git、httpd 192.168.211.92 nexus、sonarqube、docker-ce 192.168.211.93 这个是单独的环境，用于测试jenkins和docker的 关闭防火墙 # systemctl disable firewalld.service 关闭NetworkManager # systemctl stop NetworkManager 关闭selinux # cat /etc/selinux/config SELINUX=disabled 安装常用命令 # yum install -y net-tools lrzsz tree screen lsof wget ntpdate 设置时间 # crontab -e 添加 # crontab -l */5 * * * * /usr/sbin/ntpdate time1.aliyun.com 更改时区 # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 2. 安装gitlab 1.1 gitlab的安装192.168.211.90 GitHub 和 GitLab 都是基于 web 的 Git 仓库 安装依赖： # yum install curl policycoreutils openssh-server openssh-clients policycoreutils-python -y 下载rpm包 # cd /usr/local/src/ #wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-11.9.1-ce.0.el7.x86_64.rpm # rpm -ivh gitlab-ce-11.9.1-ce.0.el7.x86_64.rpm 3. 配置gitlab gitlab的默认配置文件位于：vim /etc/gitlab/gitlab.rb，修改external_url为本机的IP地址或者一个可以访问到本机的域名 external_url 'http://192.168.211.90' 修改完主配置文件后，使用gitlab-ctl reconfigure重新配置加载gitlab 4. 启动gitlab 重新配置执行成功后，就可以重新启动gitlab # gitlab-ctl restart ok: run: alertmanager: (pid 5060) 1s ok: run: gitaly: (pid 5078) 0s ok: run: gitlab-monitor: (pid 5091) 1s ok: run: gitlab-workhorse: (pid 5114) 0s ok: run: logrotate: (pid 5125) 0s ok: run: nginx: (pid 5132) 1s ok: run: node-exporter: (pid 5216) 0s ok: run: postgres-exporter: (pid 5227) 1s ok: run: postgresql: (pid 5238) 0s ok: run: prometheus: (pid 5246) 1s ok: run: redis: (pid 5260) 0s ok: run: redis-exporter: (pid 5430) 0s ok: run: sidekiq: (pid 5439) 0s ok: run: unicorn: (pid 5451) 0s 在浏览器里输入：http://192.168.211.90/，首次登陆要求重设root密码 更改密码成功后 登陆即可 5. GitLab构成 gitlab由以下服务构成，他们共同承担了gitlab的运作需要 Nginx：静态的web服务器 gitlab-shell：用于处理git命令和修改authorized keys列表 gitlab-workhorse：轻量级的反向代理服务器 logrotate：日志文件管理工具 postgresql：数据库 redis：缓存数据库 sidekiq：用于在后台执行队列任务（异步执行） unicorn：An HTTP server for Rack application，gitlab rails应用是托管在这个服务器上面的 可以使用命令来查看各个服务的状态 # gitlab-ctl status run: alertmanager: (pid 5060) 53429s; run: log: (pid 4308) 53665s run: gitaly: (pid 5078) 53428s; run: log: (pid 3570) 53739s run: gitlab-monitor: (pid 5091) 53428s; run: log: (pid 4171) 53683s run: gitlab-workhorse: (pid 5114) 53427s; run: log: (pid 3939) 53700s run: logrotate: (pid 5125) 53427s; run: log: (pid 4017) 53693s run: nginx: (pid 5132) 53427s; run: log: (pid 3967) 53699s run: node-exporter: (pid 5216) 53427s; run: log: (pid 4130) 53688s run: postgres-exporter: (pid 5227) 53427s; run: log: (pid 4356) 53660s run: postgresql: (pid 5238) 53426s; run: log: (pid 3660) 53735s run: prometheus: (pid 5246) 53426s; run: log: (pid 4242) 53672s run: redis: (pid 5260) 53425s; run: log: (pid 3387) 53746s run: redis-exporter: (pid 5430) 53425s; run: log: (pid 4210) 53678s run: sidekiq: (pid 5439) 53424s; run: log: (pid 3906) 53705s run: unicorn: (pid 5451) 53423s; run: log: (pid 3875) 53709s 5.1 gitlab shell Gitlab Shell有两个作用：为Gitlab处理git命令、修改authorized keys列表。 当通过ssh访问gitlab server 时，gitlab shell会： 调用gitlab rails api检查权限 执行pre-receive钩子（在gitlab企业版中叫做git钩子） 执行你请求的动作 处理gitlab的post-receive动作 处理自定义的post-receive动作 当通过http\\https访问gitlab server时，工作流程取决于你是从git仓库拉取(pull)代码还是向git仓库推送(push)代码 如果你是从git仓库拉取(pull)代码，gitlab rails应用会全权负责处理用户鉴权和执行git命令的工作 如果你是从git仓库推送(push)代码，gitlab rails应用既不会进行用户鉴权也不会执行git命令，它会把以下工作交由gitlab shell进行处理 调用gitlab rails api检查权限 执行pre-receive钩子（在gitlab企业版中叫做git钩子） 执行你请求的动作 处理gitlab的post-receive动作 处理自定义的post-receive动作 5.2 gitlab workhorse gitlab workhorse是一个敏捷的反向代理，它会处理一些大的http请求，比如文件的上传、文件的下载、git push/pull和git包下载。其它的请求会反向代理到gitlab rails应用，即反向代理给后端的unicorn 6. gitlab 命令 启动所有的gitlab组件 # gitlab-ctl start 停止所有gitlab组件 # gitlab-ctl stop 停止postgresql组件 # gitlab-ctl stop postgresql 停止相关的数据连接服务 # gitlab-ctl stop unicorn # gitlab-ctl stop sidekiq 重启所有gitlab组件 # gitlab-ctl restart 重启gitlab-workhorse组件 # gitlab-ctl restart gitlab-workhorse 查看服务状态 # gitlab-ctl status 如果更改了配置文件[gitlab.rb 文件]，使配置文件生效，但是会初始化除了gitlab.rb之外的所有文件 # sudo gitlab-ctl reconfigure 查看日志 # sudo gitlab-ctl tail 检查redis的日志 # sudo gitlab-ctl tail redis 7. gitlab主要目录 /var/opt/gitlab/git-data/repositories/ ：库默认存储的目录 /opt/gitlab/ ： 应用代码和相应的依赖程序存放目录 /var/opt/gitlab ： gitlab-ctl reconfigure命令编译后的应用数据和配置文件，不需要人为修改配置 /etc/gitlab ： 配置文件目录 /var/log/gitlab/ : 此目录下存放了各个组件产生的日志 /var/opt/gitlab/backups/ ： 备份文件生成的目录 gitlab关闭用户注册功能 登录web界面后 点击上方导航栏的Admin Area 点击左边的设置setting 找到Sign-up restrictions配置区域，点击扩展 去掉Sign-up enabled前面的√ 最后点击save保存按钮 8. gitlab 仓库管理 gitlab是通过组（group）的概念来统一管理仓库(project)和用户（user），通过创建组、在组下再创建仓库、再将用户加入到组，从而实现用户与仓库的权限管理 创建组 create group 在管理员页面顶部的Admin area按钮，进入管理员区域 点击new group按钮 填写必要的信息 组名、组路径、组描述 组可见级别 Visibility level ：选择谁可以访问该组、我们默认选择private即可 Private：The group and its projects can only be viewed by members. 只有授权的用户才可以看到 Internal：The group and any internal projects can be viewed by any logged in user. 只要是登录gitlab的用户都可以看到 Public：The group and any public projects can be viewed without any authentication. 只要是可以访问gitlab web页面的人都可以看到 信息填完、点击创建组 进入创建好的组管理界面 可以再找个界面下创建组用户的 9. 创建用户create user 在管理员页面点击页面顶部的Admin Area按钮，进入管理员区域 点击创建用户 填写必要的信息 用户名昵称、用户名、电子邮箱、选择用户级别 点击创建用户 进入用户的管理界面 点击页面的右上页的Edit按钮，为用户设置初始密码 也可以设置用户的其他信息 最后点击save更改 10. 用户授权（grant user） 用户创建完成后，我们就需要对用户进行授权，从而使用户可以管理仓库，有两种方式，一 是 将用户加入到组，这样用户可以管理组内的仓库；二是 直接授权用户管理仓库。通常我们采用的方式是将用户加入到相应的组，并赋予不同的角色。Gitlab中用户的角色是系统定义好的，不能更改，这一点可能不符合我们正常的思维习惯。 下面将刚创建好的nqt用户添加到xmlgrg_test组，并赋予developer的权限 在管理员区域、点击创建的组，进入组管理界面 选择用户、给予权限，点击添加 添加成功 相应权限的官方文档说明：https://docs.gitlab.com/ee/user/permissions.html 11. 创建仓库create project 在gitlab中，创建project用来存储你的程序代码、作为一个问题的跟踪器、用于代码协作、用于持续集成中的构建、测试和部署等服务。 在管理员区域点击New project 填写新建仓库的信息 创建完成后页面有这2个提示、先不要管 仓库的管理页面左侧为仓库操作的相关菜单栏、右侧空仓库下显示如何在命令行连接该仓库、非空时显示仓库内容 Command line instructions Git global setup # git config --global user.name \"Administrator\" # git config --global user.email \"admin@example.com\" Create a new repository # git clone http://192.168.137.100/xmlgrg_test/xm.git # cd xm # touch README.md # git add README.md # git commit -m \"add README\" # git push -u origin master Existing folder # cd existing_folder # git init # git remote add origin http://192.168.137.100/xmlgrg_test/xm.git # git add . # git commit -m \"Initial commit\" # git push -u origin master Existing Git repository # cd existing_repo # git remote rename origin old-origin # git remote add origin http://192.168.137.100/xmlgrg_test/xm.git # git push -u origin --all # git push -u origin --tags 将仓库加入到组后，组内的成员就可以看到该仓库 使用nqt用户登录。可以看到仓库xm 12. 配置ssh key 仓库是私有的，只有授权的用户才可以访问该仓库，那么只要客户端的用户与我们gitlab的用户绑定，客户端即可访问到gitlab上的仓库，建议使用ssh方式实现客户端与gitlab用户的绑定，具体配置如下： 在客户端生成ssh密钥对(注意 windows客户端下只能使用rsa加密方式) 在192.168.211.90 ，gitlab的服务器上 切换到运行gitlab的用户下，我这里直接使用的是服务器的root用户 # ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:TPquDQ/XGM5zBefa86ZCfKiGLh8aWHWbbVEdV06etUM root@localhost.localdomain The key's randomart image is: +---[RSA 2048]----+ | ...E*| | . o=+| | . o o . +o| | . = + = .| | . . S.o.o | | o + =++. | | . . +.Bo+.o | | .o.Ooo. o. | | .++o+ ..o. | +----[SHA256]-----+ # ll /root/.ssh/ 总用量 8 -rw------- 1 root root 1679 5月 2 17:07 id_rsa -rw-r--r-- 1 root root 408 5月 2 17:07 id_rsa.pub # cat /root/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDC9rQr5/sh7EJGMmScIJnyG+vWaXpjibA4i81ik14pdyeV80CYTmV7h38fYSKbsGI+MeQX8euvsqveGhNqJsNvTSNm/c5aoHudY6vNrvVkP1SM1gIsdgGb8I2uJeQBPi KftLnWashuO85vKiZ5hmv9THMW/Zn1NhiCuh3Ixj2PqEiUGxLLMb4NltJSoJOrOkKYZKd6FyLqXoLNJ9QN/m8uCHgS2vlTa7wvNIOZwAQnZ3Rx95dSusosUDHzfwBeMkCuNQpcP2kkQ2E6r+oi+zAlW/q6sUhHQzg0t1zat8IgEpJi3cu0TJRrdAnjNLlSL4Ue+RpmRrwoKs/gUgmrdIlZ root@localhost.localdomain 将该用户与gitlab的root用户绑定 点击gitlab用户的图标、找到setting 进入到用户的设置页面、点击左侧菜单栏的ssh keys 这个页面还可以设置用户的其它信息 Ssh的配置页面 此处只能添加公钥，注意、一个公钥在整个gitlab系统中只能添加一次，但是一个gitlab用户可以添加多个公钥 13. 推送本地客户端仓库到gitlab yum install -y git git --version 设置本仓库的global级别信息 # git config --global user.name quntao # git config --global user.email xmlgrg@163.com # git config --list user.name=quntao user.email=xmlgrg@163.com 创建一个空仓库 # pwd /data/git_test # git init 初始化空的 Git 版本库于 /data/git_test/.git/ # ll -a 总用量 0 drwxr-xr-x 3 root root 18 5月 2 20:09 . drwxr-xr-x 3 root root 22 5月 2 20:09 .. drwxr-xr-x 7 root root 119 5月 2 20:09 .git 设置过滤文件 有了仓库，我们便可以在git_test文件夹下的工作区做文件的增删修改工作了，但很多时候，我们只在意开发过程中的源文件，并不需要管理自动产生的其它临时文件。这时候便需要一个过滤文件，在这个文件中设置过滤规则，让git能够自动过滤掉那些临时文件，这个文件便是.gitignore文件。 在仓库目录下创建.gitignore文件 # pwd /data/git_test # touch .gitignore # vim .gitignore # cat .gitignore test.txt /test/ *.txt test.txt //过滤test.txt文件 /test/ //过滤test目录 *.txt //过滤所有以.txt结尾的文件 常用的通配规则： 以斜杠“/”开头表示目录 以星号“*”通配说个字符 以问号“？”通配单个字符 以方括号”[]“包含单个字符的匹配列表 以叹号“！”表示不忽略(跟踪)匹配到的文件或目录 # touch a # touch b # touch c # git add a # git add b # git add c # git commit -m \"commit a\" //\"commit a\" 提交版本的描述信息 [master（根提交） 4141cd7] commit a 3 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 a create mode 100644 b create mode 100644 c 推送本地客户端仓库到gitlab中 # pwd /data/git_test # git remote add gitlab git@192.168.137.100:xmlgrg_test/xm.git 您在 /var/spool/mail/root 中有新邮件 # git remote gitlab # ll -a 总用量 4 drwxr-xr-x 3 root root 63 5月 2 20:19 . drwxr-xr-x 3 root root 22 5月 2 20:09 .. -rw-r--r-- 1 root root 0 5月 2 20:19 a -rw-r--r-- 1 root root 0 5月 2 20:19 b -rw-r--r-- 1 root root 0 5月 2 20:19 c drwxr-xr-x 8 root root 166 5月 2 20:25 .git -rw-r--r-- 1 root root 22 5月 2 20:14 .gitignore # git push -u gitlab master The authenticity of host '192.168.137.100 (192.168.137.100)' can't be established. ECDSA key fingerprint is SHA256:zUU81Kb1Q5uS1ewufeZ1qLyErPI0uOyIhEmOabssXoE. ECDSA key fingerprint is MD5:1a:bc:a7:24:e7:f6:ce:4e:d3:df:56:ac:4a:e2:a5:3c. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.137.100' (ECDSA) to the list of known hosts. Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 203 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@192.168.137.100:xmlgrg_test/xm.git * [new branch] master -> master 分支 master 设置为跟踪来自 gitlab 的远程分支 master。 提示推送成功，我们在gitlab上的xm仓库上可以看到推送上来的内容 14. 克隆gitlab仓库到本地客户端 192.168.211.91 在这台服务器上安装git 使用yum默认安装的git版本是1.8，版本较低，我们可以使用源码安装 首先需要安装依赖库： # yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker 下载最新的源码包 # cd /usr/local/src/ # wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.2.tar.xz # tar xf git-2.19.2.tar.xz # cd git-2.19.2 # make prefix=/usr/local/git all # make prefix=/usr/local/git install # rm -rf /usr/bin/git # ln -s /usr/local/git/bin/git /usr/bin/git # git --version git version 2.19.2 生成ssh key [root@localhost git-2.19.2]# ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:deiQnPXeqNII+GsnVedBO0255UWtGto4PEbeEYSBTPo root@localhost.localdomain The key's randomart image is: +---[RSA 2048]----+ | o..o+. oo| | oo+.oo o +| | . = o.o= =.| | . . +ooBo+ .| | . . E=.Bo*. | | . ..oO.= | | ..o.oo | | o... | | ..o | +----[SHA256]-----+ [root@localhost git-2.19.2]# ll /root/.ssh/ 总用量 8 -rw------- 1 root root 1675 5月 2 20:44 id_rsa -rw-r--r-- 1 root root 408 5月 2 20:44 id_rsa.pub [root@localhost git-2.19.2]# cat /root/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCwUIYoYKPxp23ZH+Q4DmQJtuxv9AWmZUKemTVJ0cBDB03K4AhF64orfODrdGmEr1G0IllPuhMJ7HtbRR7EcsCE8MunxikRyJhb8iOYzTtTkGDy9Q0aZ/BUKx7wAmIj+u NHe+X8YUYtpMfMngtLl5XL0yHRvMoPVaUPT9FlejfRtrj3Qh8+vKiN4q9c36tC8eoyEnKE656yboTNkYE43Djp6DyynPmNcuB4dOVNz+OA+uR7OIidT6fxw16bxkCXUQeQ/Y6doMCOjBuZEUsD0VaSQ5J16ewd47cBbeEv/fVUIoZFXv5VrtowYWU6WlzMu2AQRiQs+ZeYik0L2UqcOXmP root@localhost.localdomain 然后配置192.168.211.91客户端与gitlab上的nqt用户绑定 使用git clone命令克隆仓库到192.168.211.91服务器本地 [root@localhost data]# mkdir /101 [root@localhost data]# cd /101 [root@localhost 101]# git clone git@192.168.137.100:xmlgrg_test/xm.git 正克隆到 'xm'... The authenticity of host '192.168.137.100 (192.168.137.100)' can't be established. ECDSA key fingerprint is SHA256:zUU81Kb1Q5uS1ewufeZ1qLyErPI0uOyIhEmOabssXoE. ECDSA key fingerprint is MD5:1a:bc:a7:24:e7:f6:ce:4e:d3:df:56:ac:4a:e2:a5:3c. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.137.100' (ECDSA) to the list of known hosts. remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0) 接收对象中: 100% (3/3), 完成. [root@localhost 101]# ll -a 总用量 0 drwxr-xr-x 3 root root 16 5月 2 20:49 . dr-xr-xr-x. 19 root root 247 5月 2 20:49 .. drwxr-xr-x 3 root root 45 5月 2 20:49 xm [root@localhost 101]# cd xm [root@localhost xm]# ll -a 总用量 0 drwxr-xr-x 3 root root 45 5月 2 20:49 . drwxr-xr-x 3 root root 16 5月 2 20:49 .. -rw-r--r-- 1 root root 0 5月 2 20:49 a -rw-r--r-- 1 root root 0 5月 2 20:49 b -rw-r--r-- 1 root root 0 5月 2 20:49 c drwxr-xr-x 8 root root 163 5月 2 20:49 .git [root@localhost xm]# [root@localhost xm]# git remote origin 可以看到已经将gitlab上的xm仓库克隆到192.168.137.101本地，同时为本地仓库添加了一个指向gitlab上xm仓库的远程仓库 在192.168.137.101的xm上创建一个dev的分支，并将dev分支，推送到gitlab上 [root@localhost 101]# cd xm [root@localhost xm]# pwd /101/xm [root@localhost xm]# pwd /101/xm [root@localhost xm]# git checkout -b dev 切换到一个新分支 'dev' [root@localhost xm]# git status 位于分支 dev 无文件要提交，干净的工作区 [root@localhost xm]# git push -u origin dev 总共 0 （差异 0），复用 0 （差异 0） remote: remote: To create a merge request for dev, visit: remote: http://192.168.137.100/xmlgrg_test/xm/merge_requests/new?merge_request%5Bsource_branch%5D=dev remote: To 192.168.137.100:xmlgrg_test/xm.git * [new branch] dev -> dev 分支 'dev' 设置为跟踪来自 'origin' 的远程分支 'dev'。 完成后，在gitlab上可以看到推上来的dev分支 15. 设置分支保护 在实际使用过程中，通常会保持master分支的稳定，用于生产环境的版本发布，只有授权的用户才可以向master合并代码。要实现此功能，需要将master设置为保护分支，同时授权什么用户可以向master用户推送代码。 使用root用户登录gitlab，点击xm仓库页面左下角的setting 进入设置页面，选择设置菜单栏下面的Repository选项 找到Protected Branches、点击展开 展开Protected Branches 设置完dev为保护的后，在仓库的分支页面，可看到分支后出现一个绿色的protected 默认的情况下，master分支是不允许developer角色向其推送内容的 16. Gitlab的备份、恢复、升级 对gitlab进行备份将会创建一个包含所有库和附件的归档文件，对备份的恢复只能恢复到与备份时的gitlab相同的版本。将gitlab迁移到另一台服务器上的最佳方法就是通过备份和还原。Gitlab提供了一个简单的命令行来备份整个gitlab，并且能灵活的满足需求。 备份配置 备份文件将保存在配置文件中定义的backup_path中，文件名为TIMESTAMP_GITLAB_BACKUP.TAR，TIMESTAMP为备份的时间戳。TIMESTAMP的格式为：EPOCH_YYYY_MM_DD_Gitlab-version。 默认的备份文件目录为：/var/opt/gitlab/backups，如果自定义备份目录需要赋予目录git权限，具体操作如下： 配置文件中加入： # vim /etc/gitlab/gitlab.rb ### Backup Settings ###! Docs: https://docs.gitlab.com/omnibus/settings/backups.html #gitlab_rails['manage_backup_path'] = true gitlab_rails['backup_path'] = \"/data/gitlab/backups\" #备份的目录 ##!Docs:https://docs.gitlab.com/ce/raketasks/backup_restore.html#backup-archive-permissions # gitlab_rails['backup_archive_permissions'] = 0644 # gitlab_rails['backup_pg_schema'] = 'public' ###! The duration in seconds to keep backups before they are allowed to be deleted gitlab_rails['backup_keep_time'] = 604800 #备份保留的时间(以秒为单位，这个是7天默认值) 在命令行执行命令如下 # mkdir -pv /data/gitlab/backups # chown -R git.git /data/gitlab/backups/ # gitlab-ctl reconfigure # gitlab-ctl restart 16.1 手动备份 在命令行执行： # gitlab-rake gitlab:backup:create 2019-05-18 21:26:25 +0800 -- Dumping database ... Dumping PostgreSQL database gitlabhq_production ... [DONE] 2019-05-18 21:26:25 +0800 -- done 2019-05-18 21:26:25 +0800 -- Dumping repositories ... * xmlgrg_test/xm ... [DONE] [SKIPPED] Wiki 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping uploads ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping builds ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping artifacts ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping pages ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping lfs objects ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping container registry images ... 2019-05-18 21:26:26 +0800 -- [DISABLED] Creating backup archive: 1558185986_2019_05_18_11.9.1_gitlab_backup.tar ... done Uploading backup archive to remote storage ... skipped Deleting tmp directories ... done done done done done done done done Deleting old backups ... done. (0 removed) # ll /data/gitlab/backups/ 在制定的目录下生成对应的备份文件 总用量 112 -rw------- 1 git git 112640 5月 18 21:26 1558185986_2019_05_18_11.9.1_gitlab_backup.tar 16.2 定时备份 通过在定时任务里添加： 每天凌晨2点进行一次自动备份:通过crontab使用备份命令实现，需重启cron服务 输入命令crontab -e sudo crontab -e #输入相应的任务 环境变量CRON=1的作用是如果没有任何错误发生时，抑制备份脚本的所有进度输出 0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1 # systemctl restart crond 重启服务 在crontab文件里面，每一行代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，每个字段之间用空格分割，没用的段用*代替，格式如下： m h dom mon dow user command 其中： m： 表示分钟，可以是从0到59之间的任何整数。 h：表示小时，可以是从0到23之间的任何整数。 dom：表示日期，可以是从1到31之间的任何整数。 mon：表示月份，可以是从1到12之间的任何整数。 dow：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 user : 表示执行的用户。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件(如shell文件)。 16.3 恢复实践 Gitlab的恢复只能还原到与备份文件相同的gitlab版本的系统中，恢复时，停止连接到数据库的进程(也就是停止数据的写入服务)，但是保持gitlab是运行的。 # gitlab-ctl stop unicorn ok: down: unicorn: 1s, normally up # gitlab-ctl stop sideki # gitlab-ctl status run: alertmanager: (pid 11282) 1356s; run: log: (pid 1872) 5129s run: gitaly: (pid 11298) 1355s; run: log: (pid 1859) 5129s run: gitlab-monitor: (pid 11338) 1355s; run: log: (pid 1865) 5129s run: gitlab-workhorse: (pid 11376) 1354s; run: log: (pid 1861) 5129s run: logrotate: (pid 11387) 1354s; run: log: (pid 1860) 5129s run: nginx: (pid 11397) 1353s; run: log: (pid 1852) 5129s run: node-exporter: (pid 11407) 1353s; run: log: (pid 1862) 5129s run: postgres-exporter: (pid 11508) 1352s; run: log: (pid 1869) 5129s run: postgresql: (pid 11524) 1351s; run: log: (pid 1847) 5129s run: prometheus: (pid 11540) 1350s; run: log: (pid 1877) 5129s run: redis: (pid 11559) 1349s; run: log: (pid 1875) 5129s run: redis-exporter: (pid 11598) 1349s; run: log: (pid 1870) 5129s run: sidekiq: (pid 11609) 1346s; run: log: (pid 1878) 5129s down: unicorn: 29s, normally up; run: log: (pid 1876) 5129s # 执行恢复操作 # gitlab-rake gitlab:backup:restore 整个恢复执行过程中，可以看到基本是在删除表，创建表 2处需要输入yes Before restoring the database, we will remove all existing tables to avoid future upgrade problems. Be aware that if you have custom tables in the GitLab database these tables and all data will be removed. Do you want to continue (yes/no)? yes This task will now rebuild the authorized_keys file. You will lose any data stored in the authorized_keys file. Do you want to continue (yes/no)? yes 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitlab/1_gitlab_start.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/1_gitlab_start.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/1_gitlab_start.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "},"Gitlab/2_gitlab_deploy.html":{"url":"Gitlab/2_gitlab_deploy.html","title":"gitlab 部署","keywords":"","body":" gitlab 部署1. 简介2. 准备3. 部署3.1 docker安装GitLab-ce配置存储位置3.2 Docker-compose安装gitlab4. 配置4.1 获取密码4.2 修改密码gitlab 部署 参考官方部署 Create a Continuous Integration (CI) Pipeline in Gitlab gitlab-runner部署 git 本地项目上传github或gitlab详解 git与gitlab快速学习手册 1. 简介 Gitlab是一个开源的Git代码仓库系统，可以实现自托管的Github项目，即用于构建私有的代码托管平台和项目管理系统。系统基于Ruby on Rails开发，速度快、安全稳定。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 2. 准备 install docker in ubuntu 卸载旧版本 sudo apt-get remove docker docker-engine docker.io containerd runc rm -rf /var/lib/docker/ 配置docker源 sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release #下载gpg证书 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #其他版本 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 安装docker #查看版本 apt-cache madison docker-ce sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 或者指定特定版本 sudo apt-get install docker-ce= docker-ce-cli= containerd.io 3. 部署 3.1 docker安装GitLab-ce GitLab的安装可以直接run，或者通过docker-compose文件指定安装流程，这里使用前者进行快速简单安装，后者后续更新。 拉取GitLab-ce镜像，查看镜像信息 $ docker pull gitlab/gitlab-ce $ docker image ls 配置存储位置 $ mkdir /opt/gitlab $ export GITLAB_HOME=/opt/gitlab $ echo $GITLAB_HOME /opt/gitlab 运行gitlab $ docker run -d --hostname gitlab.example.com -p 443:443 -p 80:80 -p 22:22 --name gitlab --restart always -v $GITLAB_HOME/config:/etc/gitlab:Z -v $GITLAB_HOME/logs:/var/log/gitlab:Z -v $GITLAB_HOME/data:/var/opt/gitlab:Z --shm-size 256m gitlab/gitlab-ce:latest :Z能够确保有足够的权限的权限创建文件 正常要等1~2分钟。 假如报错 bash /opt/gitlab/embedded/bin/runsvdir-start: line 24: ulimit: pending signals: cannot modify limit: Operation not permitted /opt/gitlab/embedded/bin/runsvdir-start: line 37: /proc/sys/fs/file-max: Read-only file system Configuring GitLab package... Configuring GitLab... 解决方法： chmod 2770 /opt/gitlab/data/git-data/repositories docker restart gitlab 查看容器运行情况，出现gitlab运行信息表明启动成功 $ docker ps 浏览器进入http://192.168.211.70:8080，使用root账户登录并设置密码即可进入管理员界面 环境变量GITLAB_OMNIBUS_CONFIG添加到Docker run来预先配置GitLab Docker镜像。这个变量包含任何gitlab.rb设置,，GITLAB_OMNIBUS_CONFIG中包含的设置不写入gitlab.rb配置文件。 下面是一个设置外部URL并在启动容器时启用LFS的例子: docker run --detach \\ --hostname gitlab.example.com \\ --env GITLAB_OMNIBUS_CONFIG=\"external_url 'http://my.domain.com/'; gitlab_rails['lfs_enabled'] = true;\" \\ --publish 443:443 --publish 80:80 --publish 22:22 \\ --name gitlab \\ --restart always \\ --volume $GITLAB_HOME/config:/etc/gitlab \\ --volume $GITLAB_HOME/logs:/var/log/gitlab \\ --volume $GITLAB_HOME/data:/var/opt/gitlab \\ --shm-size 256m \\ gitlab/gitlab-ee:latest 使用不同的端口 如果你想使用一个不同于80 (HTTP)或443 (HTTPS)的主机端口，你需要添加一个单独的——publish指令到docker运行命令。 $ docker run --detach \\ --hostname gitlab.example.com \\ --publish 8929:8929 --publish 2289:22 \\ --name gitlab \\ --restart always \\ --volume $GITLAB_HOME/config:/etc/gitlab \\ --volume $GITLAB_HOME/logs:/var/log/gitlab \\ --volume $GITLAB_HOME/data:/var/opt/gitlab \\ --shm-size 256m \\ gitlab/gitlab-ee:latest $ docker exec -it gitlab /bin/bash $ vi /etc/gitlab/gitlab.rb # For HTTP external_url \"http://gitlab.example.com:8929\" or # For HTTPS (notice the https) external_url \"https://gitlab.example.com:8929\" gitlab_rails['gitlab_shell_ssh_port'] = 2289 $ gitlab-ctl reconfigure 端映射格式为“hostPort:containerPort”。更多信息请参阅Docker的文档 此external_url中指定的端口必须与Docker发布给主机的端口相匹配。此外，如果NGINX监听端口没有在NGINX ['listen_port']中显式设置，它将从external_url中拉出。要了解更多信息，请参阅NGINX文档。 3.2 Docker-compose安装gitlab 使用Docker Compose，你可以轻松地配置、安装和升级基于Docker的GitLab安装: 安装docker-compose 编排docker-compose.yml version: '3.6' services: web: image: 'gitlab/gitlab-ee:latest' restart: always hostname: 'gitlab.example.com' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'https://gitlab.example.com' # Add any other gitlab.rb configuration here, each on its own line ports: - '80:80' - '443:443' - '22:22' volumes: - '$GITLAB_HOME/config:/etc/gitlab' - '$GITLAB_HOME/logs:/var/log/gitlab' - '$GITLAB_HOME/data:/var/opt/gitlab' shm_size: '256m' docker-compose up -d 如果我们自定义HTTP和SSH端口。需要定义GITLAB_OMNIBUS_CONFIG变量是如何匹配端口部分的: version: '3.6' services: web: image: 'gitlab/gitlab-ee:latest' restart: always hostname: 'gitlab.example.com' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.example.com:8929' gitlab_rails['gitlab_shell_ssh_port'] = 2224 ports: - '8929:8929' - '2224:22' volumes: - '$GITLAB_HOME/config:/etc/gitlab' - '$GITLAB_HOME/logs:/var/log/gitlab' - '$GITLAB_HOME/data:/var/opt/gitlab' shm_size: '256m' 4. 配置 4.1 获取密码 $ cat /etc/gitlab/initial_root_password # WARNING: This value is valid only in the following conditions # 1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails['initial_root_password']` setting in `gitlab.rb`, it was provided before database was seeded for the first time (usually, the first reconfigure run). # 2. Password hasn't been changed manually, either via UI or via command line. # # If the password shown here doesn't work, you must reset the admin password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password. Password: mmPPA7vlzRPgdEgQXu1LnWbok6OUNgiAgoZvhYnCgrw= # NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours. mmPPA7vlzRPgdEgQXu1LnWbok6OUNgiAgoZvhYnCgrw=是默认的初始密码， 我们可以在/etc/gitlab/gitlab.rb配置文件中设置自己的root密码，也可以用默认的密码登陆再修改自己想要的密码。要注意该文件24小时后自动删除。 4.2 修改密码 修改重新登陆即可。 作者: ghostwritten 链接: https://smoothies.com.cn/gitbook-demo/Gitlab/2_gitlab_deploy.html 来源: ghostwritten 本文原创发布于「ghostwritten」,转载请注明出处,谢谢合作! window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/2_gitlab_deploy.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"685e9494cb4c2c2912b4\",\"clientSecret\":\"efdae24f1c22c59d5878c3a35c94d75aacef6ec1\",\"repo\":\"gitbook-demo\",\"owner\":\"Ghostwritten\",\"admin\":[\"Ghostwritten\"],\"id\":\"/Gitlab/2_gitlab_deploy.html\"});gitalk.render(\"gitalk-container\"); Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 09:16:43 var enablePlugin = false; var allowDomain = \"localhost\"; if(allowDomain){ var currentDomain = location.hostname; if ($.isArray(allowDomain)) { $.each(allowDomain, function(index, item) { if (currentDomain == item) { enablePlugin = true; return false; } }); }else{ if (currentDomain == allowDomain) { enablePlugin = true; } } }else{ enablePlugin = true; } if(enablePlugin){ var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i); if (!isMobile) { var btw = new BTWPlugin(); btw.init({\"allowDomain\":\"localhost\",\"blogId\":\"30114-1655657259931-499\",\"name\":\"爱死亡机器人\",\"qrcode\":\"https://pic2.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_1440w.jpg\",\"keyword\":\"vip\",\"id\":\"vip-container\"}); } } "}}